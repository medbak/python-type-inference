Module([Expr(Str('Drop-in replacement for the thread module.\n\nMeant to be used as a brain-dead substitute so that threaded code does\nnot need to be rewritten for when the thread module is not present.\n\nSuggested usage is::\n\n    try:\n        import thread\n    except ImportError:\n        import dummy_thread as thread\n\n', lineno=13, col_offset=-1), lineno=13, col_offset=-1), Assign([Name('__all__', Store(), lineno=16, col_offset=0)], List([Str('error', lineno=16, col_offset=11), Str('start_new_thread', lineno=16, col_offset=20), Str('exit', lineno=16, col_offset=40), Str('get_ident', lineno=16, col_offset=48), Str('allocate_lock', lineno=16, col_offset=61), Str('interrupt_main', lineno=17, col_offset=11), Str('LockType', lineno=17, col_offset=29)], Load(), lineno=16, col_offset=10), lineno=16, col_offset=0), Import([alias('traceback', '_traceback')], lineno=19, col_offset=0), ClassDef('error', [Name('Exception', Load(), lineno=21, col_offset=12)], [Expr(Str('Dummy implementation of thread.error.', lineno=22, col_offset=4), lineno=22, col_offset=4), FunctionDef('__init__', arguments([Name('self', Param(), lineno=24, col_offset=17)], 'args', None, []), [Assign([Attribute(Name('self', Load(), lineno=25, col_offset=8), 'args', Store(), lineno=25, col_offset=8)], Name('args', Load(), lineno=25, col_offset=20), lineno=25, col_offset=8)], [], lineno=24, col_offset=4)], [], lineno=21, col_offset=0), FunctionDef('start_new_thread', arguments([Name('function', Param(), lineno=27, col_offset=21), Name('args', Param(), lineno=27, col_offset=31), Name('kwargs', Param(), lineno=27, col_offset=37)], None, None, [Dict([], [], lineno=27, col_offset=44)]), [Expr(Str('Dummy implementation of thread.start_new_thread().\n\n    Compatibility is maintained by making sure that ``args`` is a\n    tuple and ``kwargs`` is a dictionary.  If an exception is raised\n    and it is SystemExit (which can be done by thread.exit()) it is\n    caught and nothing is done; all other exceptions are printed out\n    by using traceback.print_exc().\n\n    If the executed function calls interrupt_main the KeyboardInterrupt will be\n    raised when the function returns.\n\n    ', lineno=39, col_offset=-1), lineno=39, col_offset=-1), If(Compare(Call(Name('type', Load(), lineno=40, col_offset=7), [Name('args', Load(), lineno=40, col_offset=12)], [], None, None, lineno=40, col_offset=7), [NotEq()], [Call(Name('type', Load(), lineno=40, col_offset=21), [Call(Name('tuple', Load(), lineno=40, col_offset=26), [], [], None, None, lineno=40, col_offset=26)], [], None, None, lineno=40, col_offset=21)], lineno=40, col_offset=7), [Raise(Call(Name('TypeError', Load(), lineno=41, col_offset=14), [Str('2nd arg must be a tuple', lineno=41, col_offset=24)], [], None, None, lineno=41, col_offset=14), None, None, lineno=41, col_offset=8)], [], lineno=40, col_offset=4), If(Compare(Call(Name('type', Load(), lineno=42, col_offset=7), [Name('kwargs', Load(), lineno=42, col_offset=12)], [], None, None, lineno=42, col_offset=7), [NotEq()], [Call(Name('type', Load(), lineno=42, col_offset=23), [Call(Name('dict', Load(), lineno=42, col_offset=28), [], [], None, None, lineno=42, col_offset=28)], [], None, None, lineno=42, col_offset=23)], lineno=42, col_offset=7), [Raise(Call(Name('TypeError', Load(), lineno=43, col_offset=14), [Str('3rd arg must be a dict', lineno=43, col_offset=24)], [], None, None, lineno=43, col_offset=14), None, None, lineno=43, col_offset=8)], [], lineno=42, col_offset=4), Global(['_main'], lineno=44, col_offset=4), Assign([Name('_main', Store(), lineno=45, col_offset=4)], Name('False', Load(), lineno=45, col_offset=12), lineno=45, col_offset=4), TryExcept([Expr(Call(Name('function', Load(), lineno=47, col_offset=8), [], [], Name('args', Load(), lineno=47, col_offset=18), Name('kwargs', Load(), lineno=47, col_offset=26), lineno=47, col_offset=8), lineno=47, col_offset=8)], [ExceptHandler(Name('SystemExit', Load(), lineno=48, col_offset=11), None, [Pass( lineno=49, col_offset=8)], lineno=48, col_offset=4), ExceptHandler(None, None, [Expr(Call(Attribute(Name('_traceback', Load(), lineno=51, col_offset=8), 'print_exc', Load(), lineno=51, col_offset=8), [], [], None, None, lineno=51, col_offset=8), lineno=51, col_offset=8)], lineno=50, col_offset=4)], [], lineno=46, col_offset=4), Assign([Name('_main', Store(), lineno=52, col_offset=4)], Name('True', Load(), lineno=52, col_offset=12), lineno=52, col_offset=4), Global(['_interrupt'], lineno=53, col_offset=4), If(Name('_interrupt', Load(), lineno=54, col_offset=7), [Assign([Name('_interrupt', Store(), lineno=55, col_offset=8)], Name('False', Load(), lineno=55, col_offset=21), lineno=55, col_offset=8), Raise(Name('KeyboardInterrupt', Load(), lineno=56, col_offset=14), None, None, lineno=56, col_offset=8)], [], lineno=54, col_offset=4)], [], lineno=27, col_offset=0), FunctionDef('exit', arguments([], None, None, []), [Expr(Str('Dummy implementation of thread.exit().', lineno=59, col_offset=4), lineno=59, col_offset=4), Raise(Name('SystemExit', Load(), lineno=60, col_offset=10), None, None, lineno=60, col_offset=4)], [], lineno=58, col_offset=0), FunctionDef('get_ident', arguments([], None, None, []), [Expr(Str('Dummy implementation of thread.get_ident().\n\n    Since this module should only be used when threadmodule is not\n    available, it is safe to assume that the current process is the\n    only thread.  Thus a constant can be safely returned.\n    ', lineno=68, col_offset=-1), lineno=68, col_offset=-1), Return(Num(-1, lineno=69, col_offset=12), lineno=69, col_offset=4)], [], lineno=62, col_offset=0), FunctionDef('allocate_lock', arguments([], None, None, []), [Expr(Str('Dummy implementation of thread.allocate_lock().', lineno=72, col_offset=4), lineno=72, col_offset=4), Return(Call(Name('LockType', Load(), lineno=73, col_offset=11), [], [], None, None, lineno=73, col_offset=11), lineno=73, col_offset=4)], [], lineno=71, col_offset=0), FunctionDef('stack_size', arguments([Name('size', Param(), lineno=75, col_offset=15)], None, None, [Name('None', Load(), lineno=75, col_offset=20)]), [Expr(Str('Dummy implementation of thread.stack_size().', lineno=76, col_offset=4), lineno=76, col_offset=4), If(Compare(Name('size', Load(), lineno=77, col_offset=7), [IsNot()], [Name('None', Load(), lineno=77, col_offset=19)], lineno=77, col_offset=7), [Raise(Call(Name('error', Load(), lineno=78, col_offset=14), [Str('setting thread stack size not supported', lineno=78, col_offset=20)], [], None, None, lineno=78, col_offset=14), None, None, lineno=78, col_offset=8)], [], lineno=77, col_offset=4), Return(Num(0, lineno=79, col_offset=11), lineno=79, col_offset=4)], [], lineno=75, col_offset=0), ClassDef('LockType', [Name('object', Load(), lineno=81, col_offset=15)], [Expr(Str('Class implementing dummy implementation of thread.LockType.\n\n    Compatibility is maintained by maintaining self.locked_status\n    which is a boolean that stores the state of the lock.  Pickling of\n    the lock, though, should not be done since if the thread module is\n    then used with an unpickled ``lock()`` from here problems could\n    occur from this class not having atomic methods.\n\n    ', lineno=90, col_offset=-1), lineno=90, col_offset=-1), FunctionDef('__init__', arguments([Name('self', Param(), lineno=92, col_offset=17)], None, None, []), [Assign([Attribute(Name('self', Load(), lineno=93, col_offset=8), 'locked_status', Store(), lineno=93, col_offset=8)], Name('False', Load(), lineno=93, col_offset=29), lineno=93, col_offset=8)], [], lineno=92, col_offset=4), FunctionDef('acquire', arguments([Name('self', Param(), lineno=95, col_offset=16), Name('waitflag', Param(), lineno=95, col_offset=22)], None, None, [Name('None', Load(), lineno=95, col_offset=31)]), [Expr(Str("Dummy implementation of acquire().\n\n        For blocking calls, self.locked_status is automatically set to\n        True and returned appropriately based on value of\n        ``waitflag``.  If it is non-blocking, then the value is\n        actually checked and not set if it is already acquired.  This\n        is all done so that threading.Condition's assert statements\n        aren't triggered and throw a little fit.\n\n        ", lineno=105, col_offset=-1), lineno=105, col_offset=-1), If(BoolOp(Or(), [Compare(Name('waitflag', Load(), lineno=106, col_offset=11), [Is()], [Name('None', Load(), lineno=106, col_offset=23)], lineno=106, col_offset=11), Name('waitflag', Load(), lineno=106, col_offset=31)], lineno=106, col_offset=11), [Assign([Attribute(Name('self', Load(), lineno=107, col_offset=12), 'locked_status', Store(), lineno=107, col_offset=12)], Name('True', Load(), lineno=107, col_offset=33), lineno=107, col_offset=12), Return(Name('True', Load(), lineno=108, col_offset=19), lineno=108, col_offset=12)], [If(UnaryOp(Not(), Attribute(Name('self', Load(), lineno=110, col_offset=19), 'locked_status', Load(), lineno=110, col_offset=19), lineno=110, col_offset=15), [Assign([Attribute(Name('self', Load(), lineno=111, col_offset=16), 'locked_status', Store(), lineno=111, col_offset=16)], Name('True', Load(), lineno=111, col_offset=37), lineno=111, col_offset=16), Return(Name('True', Load(), lineno=112, col_offset=23), lineno=112, col_offset=16)], [Return(Name('False', Load(), lineno=114, col_offset=23), lineno=114, col_offset=16)], lineno=110, col_offset=12)], lineno=106, col_offset=8)], [], lineno=95, col_offset=4), Assign([Name('__enter__', Store(), lineno=116, col_offset=4)], Name('acquire', Load(), lineno=116, col_offset=16), lineno=116, col_offset=4), FunctionDef('__exit__', arguments([Name('self', Param(), lineno=118, col_offset=17), Name('typ', Param(), lineno=118, col_offset=23), Name('val', Param(), lineno=118, col_offset=28), Name('tb', Param(), lineno=118, col_offset=33)], None, None, []), [Expr(Call(Attribute(Name('self', Load(), lineno=119, col_offset=8), 'release', Load(), lineno=119, col_offset=8), [], [], None, None, lineno=119, col_offset=8), lineno=119, col_offset=8)], [], lineno=118, col_offset=4), FunctionDef('release', arguments([Name('self', Param(), lineno=121, col_offset=16)], None, None, []), [Expr(Str('Release the dummy lock.', lineno=122, col_offset=8), lineno=122, col_offset=8), If(UnaryOp(Not(), Attribute(Name('self', Load(), lineno=125, col_offset=15), 'locked_status', Load(), lineno=125, col_offset=15), lineno=125, col_offset=11), [Raise(Name('error', Load(), lineno=126, col_offset=18), None, None, lineno=126, col_offset=12)], [], lineno=125, col_offset=8), Assign([Attribute(Name('self', Load(), lineno=127, col_offset=8), 'locked_status', Store(), lineno=127, col_offset=8)], Name('False', Load(), lineno=127, col_offset=29), lineno=127, col_offset=8), Return(Name('True', Load(), lineno=128, col_offset=15), lineno=128, col_offset=8)], [], lineno=121, col_offset=4), FunctionDef('locked', arguments([Name('self', Param(), lineno=130, col_offset=15)], None, None, []), [Return(Attribute(Name('self', Load(), lineno=131, col_offset=15), 'locked_status', Load(), lineno=131, col_offset=15), lineno=131, col_offset=8)], [], lineno=130, col_offset=4)], [], lineno=81, col_offset=0), Assign([Name('_interrupt', Store(), lineno=134, col_offset=0)], Name('False', Load(), lineno=134, col_offset=13), lineno=134, col_offset=0), Assign([Name('_main', Store(), lineno=136, col_offset=0)], Name('True', Load(), lineno=136, col_offset=8), lineno=136, col_offset=0), FunctionDef('interrupt_main', arguments([], None, None, []), [Expr(Str('Set _interrupt flag to True to have start_new_thread raise\n    KeyboardInterrupt upon exiting.', lineno=140, col_offset=-1), lineno=140, col_offset=-1), If(Name('_main', Load(), lineno=141, col_offset=7), [Raise(Name('KeyboardInterrupt', Load(), lineno=142, col_offset=14), None, None, lineno=142, col_offset=8)], [Global(['_interrupt'], lineno=144, col_offset=8), Assign([Name('_interrupt', Store(), lineno=145, col_offset=8)], Name('True', Load(), lineno=145, col_offset=21), lineno=145, col_offset=8)], lineno=141, col_offset=4)], [], lineno=138, col_offset=0)])
