Module([ImportFrom('test.test_support', [alias('sortdict', None)], 0, lineno=11, col_offset=0), Import([alias('pprint', None)], lineno=12, col_offset=0), ClassDef('defaultdict', [Name('dict', Load(), lineno=14, col_offset=18)], [FunctionDef('__init__', arguments([Name('self', Param(), lineno=15, col_offset=17), Name('default', Param(), lineno=15, col_offset=23)], None, None, [Name('None', Load(), lineno=15, col_offset=31)]), [Expr(Call(Attribute(Name('dict', Load(), lineno=16, col_offset=8), '__init__', Load(), lineno=16, col_offset=8), [Name('self', Load(), lineno=16, col_offset=22)], [], None, None, lineno=16, col_offset=8), lineno=16, col_offset=8), Assign([Attribute(Name('self', Load(), lineno=17, col_offset=8), 'default', Store(), lineno=17, col_offset=8)], Name('default', Load(), lineno=17, col_offset=23), lineno=17, col_offset=8)], [], lineno=15, col_offset=4), FunctionDef('__getitem__', arguments([Name('self', Param(), lineno=19, col_offset=20), Name('key', Param(), lineno=19, col_offset=26)], None, None, []), [TryExcept([Return(Call(Attribute(Name('dict', Load(), lineno=21, col_offset=19), '__getitem__', Load(), lineno=21, col_offset=19), [Name('self', Load(), lineno=21, col_offset=36), Name('key', Load(), lineno=21, col_offset=42)], [], None, None, lineno=21, col_offset=19), lineno=21, col_offset=12)], [ExceptHandler(Name('KeyError', Load(), lineno=22, col_offset=15), None, [Return(Attribute(Name('self', Load(), lineno=23, col_offset=19), 'default', Load(), lineno=23, col_offset=19), lineno=23, col_offset=12)], lineno=22, col_offset=8)], [], lineno=20, col_offset=8)], [], lineno=19, col_offset=4), FunctionDef('get', arguments([Name('self', Param(), lineno=25, col_offset=12), Name('key', Param(), lineno=25, col_offset=18)], 'args', None, []), [If(UnaryOp(Not(), Name('args', Load(), lineno=26, col_offset=15), lineno=26, col_offset=11), [Assign([Name('args', Store(), lineno=27, col_offset=12)], Tuple([Attribute(Name('self', Load(), lineno=27, col_offset=20), 'default', Load(), lineno=27, col_offset=20)], Load(), lineno=27, col_offset=20), lineno=27, col_offset=12)], [], lineno=26, col_offset=8), Return(Call(Attribute(Name('dict', Load(), lineno=28, col_offset=15), 'get', Load(), lineno=28, col_offset=15), [Name('self', Load(), lineno=28, col_offset=24), Name('key', Load(), lineno=28, col_offset=30)], [], Name('args', Load(), lineno=28, col_offset=36), None, lineno=28, col_offset=15), lineno=28, col_offset=8)], [], lineno=25, col_offset=4), FunctionDef('merge', arguments([Name('self', Param(), lineno=30, col_offset=14), Name('other', Param(), lineno=30, col_offset=20)], None, None, []), [For(Name('key', Store(), lineno=31, col_offset=12), Name('other', Load(), lineno=31, col_offset=19), [If(Compare(Name('key', Load(), lineno=32, col_offset=15), [NotIn()], [Name('self', Load(), lineno=32, col_offset=26)], lineno=32, col_offset=15), [Assign([Subscript(Name('self', Load(), lineno=33, col_offset=16), Index(Name('key', Load(), lineno=33, col_offset=21)), Store(), lineno=33, col_offset=16)], Subscript(Name('other', Load(), lineno=33, col_offset=28), Index(Name('key', Load(), lineno=33, col_offset=34)), Load(), lineno=33, col_offset=28), lineno=33, col_offset=16)], [], lineno=32, col_offset=12)], [], lineno=31, col_offset=8)], [], lineno=30, col_offset=4)], [], lineno=14, col_offset=0), Assign([Name('test_1', Store(), lineno=35, col_offset=0)], Str('\n\nHere\'s the new type at work:\n\n    >>> print defaultdict               # show our type\n    <class \'test.test_descrtut.defaultdict\'>\n    >>> print type(defaultdict)         # its metatype\n    <type \'type\'>\n    >>> a = defaultdict(default=0.0)    # create an instance\n    >>> print a                         # show the instance\n    {}\n    >>> print type(a)                   # show its type\n    <class \'test.test_descrtut.defaultdict\'>\n    >>> print a.__class__               # show its class\n    <class \'test.test_descrtut.defaultdict\'>\n    >>> print type(a) is a.__class__    # its type is its class\n    True\n    >>> a[1] = 3.25                     # modify the instance\n    >>> print a                         # show the new value\n    {1: 3.25}\n    >>> print a[1]                      # show the new item\n    3.25\n    >>> print a[0]                      # a non-existent item\n    0.0\n    >>> a.merge({1:100, 2:200})         # use a dict method\n    >>> print sortdict(a)               # show the result\n    {1: 3.25, 2: 200}\n    >>>\n\nWe can also use the new type in contexts where classic only allows "real"\ndictionaries, such as the locals/globals dictionaries for the exec\nstatement or the built-in function eval():\n\n    >>> def sorted(seq):\n    ...     seq.sort(key=str)\n    ...     return seq\n    >>> print sorted(a.keys())\n    [1, 2]\n    >>> exec "x = 3; print x" in a\n    3\n    >>> print sorted(a.keys())\n    [1, 2, \'__builtins__\', \'x\']\n    >>> print a[\'x\']\n    3\n    >>>\n\nNow I\'ll show that defaultdict instances have dynamic instance variables,\njust like classic classes:\n\n    >>> a.default = -1\n    >>> print a["noway"]\n    -1\n    >>> a.default = -1000\n    >>> print a["noway"]\n    -1000\n    >>> \'default\' in dir(a)\n    True\n    >>> a.x1 = 100\n    >>> a.x2 = 200\n    >>> print a.x1\n    100\n    >>> d = dir(a)\n    >>> \'default\' in d and \'x1\' in d and \'x2\' in d\n    True\n    >>> print sortdict(a.__dict__)\n    {\'default\': -1000, \'x1\': 100, \'x2\': 200}\n    >>>\n', lineno=102, col_offset=-1), lineno=35, col_offset=0), ClassDef('defaultdict2', [Name('dict', Load(), lineno=104, col_offset=19)], [Assign([Name('__slots__', Store(), lineno=105, col_offset=4)], List([Str('default', lineno=105, col_offset=17)], Load(), lineno=105, col_offset=16), lineno=105, col_offset=4), FunctionDef('__init__', arguments([Name('self', Param(), lineno=107, col_offset=17), Name('default', Param(), lineno=107, col_offset=23)], None, None, [Name('None', Load(), lineno=107, col_offset=31)]), [Expr(Call(Attribute(Name('dict', Load(), lineno=108, col_offset=8), '__init__', Load(), lineno=108, col_offset=8), [Name('self', Load(), lineno=108, col_offset=22)], [], None, None, lineno=108, col_offset=8), lineno=108, col_offset=8), Assign([Attribute(Name('self', Load(), lineno=109, col_offset=8), 'default', Store(), lineno=109, col_offset=8)], Name('default', Load(), lineno=109, col_offset=23), lineno=109, col_offset=8)], [], lineno=107, col_offset=4), FunctionDef('__getitem__', arguments([Name('self', Param(), lineno=111, col_offset=20), Name('key', Param(), lineno=111, col_offset=26)], None, None, []), [TryExcept([Return(Call(Attribute(Name('dict', Load(), lineno=113, col_offset=19), '__getitem__', Load(), lineno=113, col_offset=19), [Name('self', Load(), lineno=113, col_offset=36), Name('key', Load(), lineno=113, col_offset=42)], [], None, None, lineno=113, col_offset=19), lineno=113, col_offset=12)], [ExceptHandler(Name('KeyError', Load(), lineno=114, col_offset=15), None, [Return(Attribute(Name('self', Load(), lineno=115, col_offset=19), 'default', Load(), lineno=115, col_offset=19), lineno=115, col_offset=12)], lineno=114, col_offset=8)], [], lineno=112, col_offset=8)], [], lineno=111, col_offset=4), FunctionDef('get', arguments([Name('self', Param(), lineno=117, col_offset=12), Name('key', Param(), lineno=117, col_offset=18)], 'args', None, []), [If(UnaryOp(Not(), Name('args', Load(), lineno=118, col_offset=15), lineno=118, col_offset=11), [Assign([Name('args', Store(), lineno=119, col_offset=12)], Tuple([Attribute(Name('self', Load(), lineno=119, col_offset=20), 'default', Load(), lineno=119, col_offset=20)], Load(), lineno=119, col_offset=20), lineno=119, col_offset=12)], [], lineno=118, col_offset=8), Return(Call(Attribute(Name('dict', Load(), lineno=120, col_offset=15), 'get', Load(), lineno=120, col_offset=15), [Name('self', Load(), lineno=120, col_offset=24), Name('key', Load(), lineno=120, col_offset=30)], [], Name('args', Load(), lineno=120, col_offset=36), None, lineno=120, col_offset=15), lineno=120, col_offset=8)], [], lineno=117, col_offset=4), FunctionDef('merge', arguments([Name('self', Param(), lineno=122, col_offset=14), Name('other', Param(), lineno=122, col_offset=20)], None, None, []), [For(Name('key', Store(), lineno=123, col_offset=12), Name('other', Load(), lineno=123, col_offset=19), [If(Compare(Name('key', Load(), lineno=124, col_offset=15), [NotIn()], [Name('self', Load(), lineno=124, col_offset=26)], lineno=124, col_offset=15), [Assign([Subscript(Name('self', Load(), lineno=125, col_offset=16), Index(Name('key', Load(), lineno=125, col_offset=21)), Store(), lineno=125, col_offset=16)], Subscript(Name('other', Load(), lineno=125, col_offset=28), Index(Name('key', Load(), lineno=125, col_offset=34)), Load(), lineno=125, col_offset=28), lineno=125, col_offset=16)], [], lineno=124, col_offset=12)], [], lineno=123, col_offset=8)], [], lineno=122, col_offset=4)], [], lineno=104, col_offset=0), Assign([Name('test_2', Store(), lineno=127, col_offset=0)], Str('\n\nThe __slots__ declaration takes a list of instance variables, and reserves\nspace for exactly these in the instance. When __slots__ is used, other\ninstance variables cannot be assigned to:\n\n    >>> a = defaultdict2(default=0.0)\n    >>> a[1]\n    0.0\n    >>> a.default = -1\n    >>> a[1]\n    -1\n    >>> a.x1 = 1\n    Traceback (most recent call last):\n      File "<stdin>", line 1, in ?\n    AttributeError: \'defaultdict2\' object has no attribute \'x1\'\n    >>>\n\n', lineno=145, col_offset=-1), lineno=127, col_offset=0), Assign([Name('test_3', Store(), lineno=147, col_offset=0)], Str('\n\nIntrospecting instances of built-in types\n\nFor instance of built-in types, x.__class__ is now the same as type(x):\n\n    >>> type([])\n    <type \'list\'>\n    >>> [].__class__\n    <type \'list\'>\n    >>> list\n    <type \'list\'>\n    >>> isinstance([], list)\n    True\n    >>> isinstance([], dict)\n    False\n    >>> isinstance([], object)\n    True\n    >>>\n\nUnder the new proposal, the __methods__ attribute no longer exists:\n\n    >>> [].__methods__\n    Traceback (most recent call last):\n      File "<stdin>", line 1, in ?\n    AttributeError: \'list\' object has no attribute \'__methods__\'\n    >>>\n\nInstead, you can get the same information from the list type:\n\n    >>> pprint.pprint(dir(list))    # like list.__dict__.keys(), but sorted\n    [\'__add__\',\n     \'__class__\',\n     \'__contains__\',\n     \'__delattr__\',\n     \'__delitem__\',\n     \'__delslice__\',\n     \'__doc__\',\n     \'__eq__\',\n     \'__format__\',\n     \'__ge__\',\n     \'__getattribute__\',\n     \'__getitem__\',\n     \'__getslice__\',\n     \'__gt__\',\n     \'__hash__\',\n     \'__iadd__\',\n     \'__imul__\',\n     \'__init__\',\n     \'__iter__\',\n     \'__le__\',\n     \'__len__\',\n     \'__lt__\',\n     \'__mul__\',\n     \'__ne__\',\n     \'__new__\',\n     \'__reduce__\',\n     \'__reduce_ex__\',\n     \'__repr__\',\n     \'__reversed__\',\n     \'__rmul__\',\n     \'__setattr__\',\n     \'__setitem__\',\n     \'__setslice__\',\n     \'__sizeof__\',\n     \'__str__\',\n     \'__subclasshook__\',\n     \'append\',\n     \'count\',\n     \'extend\',\n     \'index\',\n     \'insert\',\n     \'pop\',\n     \'remove\',\n     \'reverse\',\n     \'sort\']\n\nThe new introspection API gives more information than the old one:  in\naddition to the regular methods, it also shows the methods that are\nnormally invoked through special notations, e.g. __iadd__ (+=), __len__\n(len), __ne__ (!=). You can invoke any method from this list directly:\n\n    >>> a = [\'tic\', \'tac\']\n    >>> list.__len__(a)          # same as len(a)\n    2\n    >>> a.__len__()              # ditto\n    2\n    >>> list.append(a, \'toe\')    # same as a.append(\'toe\')\n    >>> a\n    [\'tic\', \'tac\', \'toe\']\n    >>>\n\nThis is just like it is for user-defined classes.\n', lineno=240, col_offset=-1), lineno=147, col_offset=0), Assign([Name('test_4', Store(), lineno=242, col_offset=0)], Str('\n\nStatic methods and class methods\n\nThe new introspection API makes it possible to add static methods and class\nmethods. Static methods are easy to describe: they behave pretty much like\nstatic methods in C++ or Java. Here\'s an example:\n\n    >>> class C:\n    ...\n    ...     @staticmethod\n    ...     def foo(x, y):\n    ...         print "staticmethod", x, y\n\n    >>> C.foo(1, 2)\n    staticmethod 1 2\n    >>> c = C()\n    >>> c.foo(1, 2)\n    staticmethod 1 2\n\nClass methods use a similar pattern to declare methods that receive an\nimplicit first argument that is the *class* for which they are invoked.\n\n    >>> class C:\n    ...     @classmethod\n    ...     def foo(cls, y):\n    ...         print "classmethod", cls, y\n\n    >>> C.foo(1)\n    classmethod test.test_descrtut.C 1\n    >>> c = C()\n    >>> c.foo(1)\n    classmethod test.test_descrtut.C 1\n\n    >>> class D(C):\n    ...     pass\n\n    >>> D.foo(1)\n    classmethod test.test_descrtut.D 1\n    >>> d = D()\n    >>> d.foo(1)\n    classmethod test.test_descrtut.D 1\n\nThis prints "classmethod __main__.D 1" both times; in other words, the\nclass passed as the first argument of foo() is the class involved in the\ncall, not the class involved in the definition of foo().\n\nBut notice this:\n\n    >>> class E(C):\n    ...     @classmethod\n    ...     def foo(cls, y): # override C.foo\n    ...         print "E.foo() called"\n    ...         C.foo(y)\n\n    >>> E.foo(1)\n    E.foo() called\n    classmethod test.test_descrtut.C 1\n    >>> e = E()\n    >>> e.foo(1)\n    E.foo() called\n    classmethod test.test_descrtut.C 1\n\nIn this example, the call to C.foo() from E.foo() will see class C as its\nfirst argument, not class E. This is to be expected, since the call\nspecifies the class C. But it stresses the difference between these class\nmethods and methods defined in metaclasses (where an upcall to a metamethod\nwould pass the target class as an explicit first argument).\n', lineno=310, col_offset=-1), lineno=242, col_offset=0), Assign([Name('test_5', Store(), lineno=312, col_offset=0)], Str('\n\nAttributes defined by get/set methods\n\n\n    >>> class property(object):\n    ...\n    ...     def __init__(self, get, set=None):\n    ...         self.__get = get\n    ...         self.__set = set\n    ...\n    ...     def __get__(self, inst, type=None):\n    ...         return self.__get(inst)\n    ...\n    ...     def __set__(self, inst, value):\n    ...         if self.__set is None:\n    ...             raise AttributeError, "this attribute is read-only"\n    ...         return self.__set(inst, value)\n\nNow let\'s define a class with an attribute x defined by a pair of methods,\ngetx() and and setx():\n\n    >>> class C(object):\n    ...\n    ...     def __init__(self):\n    ...         self.__x = 0\n    ...\n    ...     def getx(self):\n    ...         return self.__x\n    ...\n    ...     def setx(self, x):\n    ...         if x < 0: x = 0\n    ...         self.__x = x\n    ...\n    ...     x = property(getx, setx)\n\nHere\'s a small demonstration:\n\n    >>> a = C()\n    >>> a.x = 10\n    >>> print a.x\n    10\n    >>> a.x = -10\n    >>> print a.x\n    0\n    >>>\n\nHmm -- property is builtin now, so let\'s try it that way too.\n\n    >>> del property  # unmask the builtin\n    >>> property\n    <type \'property\'>\n\n    >>> class C(object):\n    ...     def __init__(self):\n    ...         self.__x = 0\n    ...     def getx(self):\n    ...         return self.__x\n    ...     def setx(self, x):\n    ...         if x < 0: x = 0\n    ...         self.__x = x\n    ...     x = property(getx, setx)\n\n\n    >>> a = C()\n    >>> a.x = 10\n    >>> print a.x\n    10\n    >>> a.x = -10\n    >>> print a.x\n    0\n    >>>\n', lineno=384, col_offset=-1), lineno=312, col_offset=0), Assign([Name('test_6', Store(), lineno=386, col_offset=0)], Str('\n\nMethod resolution order\n\nThis example is implicit in the writeup.\n\n>>> class A:    # classic class\n...     def save(self):\n...         print "called A.save()"\n>>> class B(A):\n...     pass\n>>> class C(A):\n...     def save(self):\n...         print "called C.save()"\n>>> class D(B, C):\n...     pass\n\n>>> D().save()\ncalled A.save()\n\n>>> class A(object):  # new class\n...     def save(self):\n...         print "called A.save()"\n>>> class B(A):\n...     pass\n>>> class C(A):\n...     def save(self):\n...         print "called C.save()"\n>>> class D(B, C):\n...     pass\n\n>>> D().save()\ncalled C.save()\n', lineno=419, col_offset=-1), lineno=386, col_offset=0), ClassDef('A', [Name('object', Load(), lineno=421, col_offset=8)], [FunctionDef('m', arguments([Name('self', Param(), lineno=422, col_offset=10)], None, None, []), [Return(Str('A', lineno=423, col_offset=15), lineno=423, col_offset=8)], [], lineno=422, col_offset=4)], [], lineno=421, col_offset=0), ClassDef('B', [Name('A', Load(), lineno=425, col_offset=8)], [FunctionDef('m', arguments([Name('self', Param(), lineno=426, col_offset=10)], None, None, []), [Return(BinOp(Str('B', lineno=427, col_offset=15), Add(), Call(Attribute(Call(Name('super', Load(), lineno=427, col_offset=21), [Name('B', Load(), lineno=427, col_offset=27), Name('self', Load(), lineno=427, col_offset=30)], [], None, None, lineno=427, col_offset=21), 'm', Load(), lineno=427, col_offset=21), [], [], None, None, lineno=427, col_offset=21), lineno=427, col_offset=15), lineno=427, col_offset=8)], [], lineno=426, col_offset=4)], [], lineno=425, col_offset=0), ClassDef('C', [Name('A', Load(), lineno=429, col_offset=8)], [FunctionDef('m', arguments([Name('self', Param(), lineno=430, col_offset=10)], None, None, []), [Return(BinOp(Str('C', lineno=431, col_offset=15), Add(), Call(Attribute(Call(Name('super', Load(), lineno=431, col_offset=21), [Name('C', Load(), lineno=431, col_offset=27), Name('self', Load(), lineno=431, col_offset=30)], [], None, None, lineno=431, col_offset=21), 'm', Load(), lineno=431, col_offset=21), [], [], None, None, lineno=431, col_offset=21), lineno=431, col_offset=15), lineno=431, col_offset=8)], [], lineno=430, col_offset=4)], [], lineno=429, col_offset=0), ClassDef('D', [Name('C', Load(), lineno=433, col_offset=8), Name('B', Load(), lineno=433, col_offset=11)], [FunctionDef('m', arguments([Name('self', Param(), lineno=434, col_offset=10)], None, None, []), [Return(BinOp(Str('D', lineno=435, col_offset=15), Add(), Call(Attribute(Call(Name('super', Load(), lineno=435, col_offset=21), [Name('D', Load(), lineno=435, col_offset=27), Name('self', Load(), lineno=435, col_offset=30)], [], None, None, lineno=435, col_offset=21), 'm', Load(), lineno=435, col_offset=21), [], [], None, None, lineno=435, col_offset=21), lineno=435, col_offset=15), lineno=435, col_offset=8)], [], lineno=434, col_offset=4)], [], lineno=433, col_offset=0), Assign([Name('test_7', Store(), lineno=438, col_offset=0)], Str('\n\nCooperative methods and "super"\n\n>>> print D().m() # "DCBA"\nDCBA\n', lineno=444, col_offset=-1), lineno=438, col_offset=0), Assign([Name('test_8', Store(), lineno=446, col_offset=0)], Str('\n\nBackwards incompatibilities\n\n>>> class A:\n...     def foo(self):\n...         print "called A.foo()"\n\n>>> class B(A):\n...     pass\n\n>>> class C(A):\n...     def foo(self):\n...         B.foo(self)\n\n>>> C().foo()\nTraceback (most recent call last):\n ...\nTypeError: unbound method foo() must be called with B instance as first argument (got C instance instead)\n\n>>> class C(A):\n...     def foo(self):\n...         A.foo(self)\n>>> C().foo()\ncalled A.foo()\n', lineno=471, col_offset=-1), lineno=446, col_offset=0), Assign([Name('__test__', Store(), lineno=473, col_offset=0)], Dict([Str('tut1', lineno=473, col_offset=12), Str('tut2', lineno=474, col_offset=12), Str('tut3', lineno=475, col_offset=12), Str('tut4', lineno=476, col_offset=12), Str('tut5', lineno=477, col_offset=12), Str('tut6', lineno=478, col_offset=12), Str('tut7', lineno=479, col_offset=12), Str('tut8', lineno=480, col_offset=12)], [Name('test_1', Load(), lineno=473, col_offset=20), Name('test_2', Load(), lineno=474, col_offset=20), Name('test_3', Load(), lineno=475, col_offset=20), Name('test_4', Load(), lineno=476, col_offset=20), Name('test_5', Load(), lineno=477, col_offset=20), Name('test_6', Load(), lineno=478, col_offset=20), Name('test_7', Load(), lineno=479, col_offset=20), Name('test_8', Load(), lineno=480, col_offset=20)], lineno=473, col_offset=11), lineno=473, col_offset=0), FunctionDef('test_main', arguments([Name('verbose', Param(), lineno=486, col_offset=14)], None, None, [Name('None', Load(), lineno=486, col_offset=22)]), [ImportFrom('test', [alias('test_support', None), alias('test_descrtut', None)], 0, lineno=492, col_offset=4), Expr(Call(Attribute(Name('test_support', Load(), lineno=493, col_offset=4), 'run_doctest', Load(), lineno=493, col_offset=4), [Name('test_descrtut', Load(), lineno=493, col_offset=29), Name('verbose', Load(), lineno=493, col_offset=44)], [], None, None, lineno=493, col_offset=4), lineno=493, col_offset=4)], [], lineno=486, col_offset=0), If(Compare(Name('__name__', Load(), lineno=496, col_offset=3), [Eq()], [Str('__main__', lineno=496, col_offset=15)], lineno=496, col_offset=3), [Expr(Call(Name('test_main', Load(), lineno=497, col_offset=4), [Num(1, lineno=497, col_offset=14)], [], None, None, lineno=497, col_offset=4), lineno=497, col_offset=4)], [], lineno=496, col_offset=0)])
