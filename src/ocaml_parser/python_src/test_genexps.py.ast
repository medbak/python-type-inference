Module([Assign([Name('doctests', Store(), lineno=1, col_offset=0)], Str('\n\nTest simple loop with conditional\n\n    >>> sum(i*i for i in range(100) if i&1 == 1)\n    166650\n\nTest simple nesting\n\n    >>> list((i,j) for i in range(3) for j in range(4) )\n    [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3)]\n\nTest nesting with the inner expression dependent on the outer\n\n    >>> list((i,j) for i in range(4) for j in range(i) )\n    [(1, 0), (2, 0), (2, 1), (3, 0), (3, 1), (3, 2)]\n\nMake sure the induction variable is not exposed\n\n    >>> i = 20\n    >>> sum(i*i for i in range(100))\n    328350\n    >>> i\n    20\n\nTest first class\n\n    >>> g = (i*i for i in range(4))\n    >>> type(g)\n    <type \'generator\'>\n    >>> list(g)\n    [0, 1, 4, 9]\n\nTest direct calls to next()\n\n    >>> g = (i*i for i in range(3))\n    >>> g.next()\n    0\n    >>> g.next()\n    1\n    >>> g.next()\n    4\n    >>> g.next()\n    Traceback (most recent call last):\n      File "<pyshell#21>", line 1, in -toplevel-\n        g.next()\n    StopIteration\n\nDoes it stay stopped?\n\n    >>> g.next()\n    Traceback (most recent call last):\n      File "<pyshell#21>", line 1, in -toplevel-\n        g.next()\n    StopIteration\n    >>> list(g)\n    []\n\nTest running gen when defining function is out of scope\n\n    >>> def f(n):\n    ...     return (i*i for i in xrange(n))\n    >>> list(f(10))\n    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n    >>> def f(n):\n    ...     return ((i,j) for i in xrange(3) for j in xrange(n))\n    >>> list(f(4))\n    [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3)]\n    >>> def f(n):\n    ...     return ((i,j) for i in xrange(3) for j in xrange(4) if j in xrange(n))\n    >>> list(f(4))\n    [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3)]\n    >>> list(f(2))\n    [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]\n\nVerify that parenthesis are required in a statement\n\n    >>> def f(n):\n    ...     return i*i for i in xrange(n)\n    Traceback (most recent call last):\n       ...\n    SyntaxError: invalid syntax\n\nVerify that parenthesis are required when used as a keyword argument value\n\n    >>> dict(a = i for i in xrange(10))\n    Traceback (most recent call last):\n       ...\n    SyntaxError: invalid syntax\n\nVerify that parenthesis are required when used as a keyword argument value\n\n    >>> dict(a = (i for i in xrange(10))) #doctest: +ELLIPSIS\n    {\'a\': <generator object <genexpr> at ...>}\n\nVerify early binding for the outermost for-expression\n\n    >>> x=10\n    >>> g = (i*i for i in range(x))\n    >>> x = 5\n    >>> list(g)\n    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\nVerify that the outermost for-expression makes an immediate check\nfor iterability\n\n    >>> (i for i in 6)\n    Traceback (most recent call last):\n      File "<pyshell#4>", line 1, in -toplevel-\n        (i for i in 6)\n    TypeError: \'int\' object is not iterable\n\nVerify late binding for the outermost if-expression\n\n    >>> include = (2,4,6,8)\n    >>> g = (i*i for i in range(10) if i in include)\n    >>> include = (1,3,5,7,9)\n    >>> list(g)\n    [1, 9, 25, 49, 81]\n\nVerify late binding for the innermost for-expression\n\n    >>> g = ((i,j) for i in range(3) for j in range(x))\n    >>> x = 4\n    >>> list(g)\n    [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3)]\n\nVerify re-use of tuples (a side benefit of using genexps over listcomps)\n\n    >>> tupleids = map(id, ((i,i) for i in xrange(10)))\n    >>> int(max(tupleids) - min(tupleids))\n    0\n\nVerify that syntax error\'s are raised for genexps used as lvalues\n\n    >>> (y for y in (1,2)) = 10\n    Traceback (most recent call last):\n       ...\n      File "<doctest test.test_genexps.__test__.doctests[40]>", line 1\n    SyntaxError: can\'t assign to generator expression\n\n    >>> (y for y in (1,2)) += 10\n    Traceback (most recent call last):\n       ...\n      File "<doctest test.test_genexps.__test__.doctests[41]>", line 1\n    SyntaxError: can\'t assign to generator expression\n\n\n########### Tests borrowed from or inspired by test_generators.py ############\n\nMake a generator that acts like range()\n\n    >>> yrange = lambda n:  (i for i in xrange(n))\n    >>> list(yrange(10))\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nGenerators always return to the most recent caller:\n\n    >>> def creator():\n    ...     r = yrange(5)\n    ...     print "creator", r.next()\n    ...     return r\n    >>> def caller():\n    ...     r = creator()\n    ...     for i in r:\n    ...             print "caller", i\n    >>> caller()\n    creator 0\n    caller 1\n    caller 2\n    caller 3\n    caller 4\n\nGenerators can call other generators:\n\n    >>> def zrange(n):\n    ...     for i in yrange(n):\n    ...         yield i\n    >>> list(zrange(5))\n    [0, 1, 2, 3, 4]\n\n\nVerify that a gen exp cannot be resumed while it is actively running:\n\n    >>> g = (me.next() for i in xrange(10))\n    >>> me = g\n    >>> me.next()\n    Traceback (most recent call last):\n      File "<pyshell#30>", line 1, in -toplevel-\n        me.next()\n      File "<pyshell#28>", line 1, in <generator expression>\n        g = (me.next() for i in xrange(10))\n    ValueError: generator already executing\n\nVerify exception propagation\n\n    >>> g = (10 // i for i in (5, 0, 2))\n    >>> g.next()\n    2\n    >>> g.next()\n    Traceback (most recent call last):\n      File "<pyshell#37>", line 1, in -toplevel-\n        g.next()\n      File "<pyshell#35>", line 1, in <generator expression>\n        g = (10 // i for i in (5, 0, 2))\n    ZeroDivisionError: integer division or modulo by zero\n    >>> g.next()\n    Traceback (most recent call last):\n      File "<pyshell#38>", line 1, in -toplevel-\n        g.next()\n    StopIteration\n\nMake sure that None is a valid return value\n\n    >>> list(None for i in xrange(10))\n    [None, None, None, None, None, None, None, None, None, None]\n\nCheck that generator attributes are present\n\n    >>> g = (i*i for i in range(3))\n    >>> expected = set([\'gi_frame\', \'gi_running\', \'next\'])\n    >>> set(attr for attr in dir(g) if not attr.startswith(\'__\')) >= expected\n    True\n\n    >>> print g.next.__doc__\n    x.next() -> the next value, or raise StopIteration\n    >>> import types\n    >>> isinstance(g, types.GeneratorType)\n    True\n\nCheck the __iter__ slot is defined to return self\n\n    >>> iter(g) is g\n    True\n\nVerify that the running flag is set properly\n\n    >>> g = (me.gi_running for i in (0,1))\n    >>> me = g\n    >>> me.gi_running\n    0\n    >>> me.next()\n    1\n    >>> me.gi_running\n    0\n\nVerify that genexps are weakly referencable\n\n    >>> import weakref\n    >>> g = (i*i for i in range(4))\n    >>> wr = weakref.ref(g)\n    >>> wr() is g\n    True\n    >>> p = weakref.proxy(g)\n    >>> list(p)\n    [0, 1, 4, 9]\n\n\n', lineno=260, col_offset=-1), lineno=1, col_offset=0), Assign([Name('__test__', Store(), lineno=263, col_offset=0)], Dict([Str('doctests', lineno=263, col_offset=12)], [Name('doctests', Load(), lineno=263, col_offset=25)], lineno=263, col_offset=11), lineno=263, col_offset=0), FunctionDef('test_main', arguments([Name('verbose', Param(), lineno=265, col_offset=14)], None, None, [Name('None', Load(), lineno=265, col_offset=22)]), [Import([alias('sys', None)], lineno=266, col_offset=4), ImportFrom('test', [alias('test_support', None)], 0, lineno=267, col_offset=4), ImportFrom('test', [alias('test_genexps', None)], 0, lineno=268, col_offset=4), Expr(Call(Attribute(Name('test_support', Load(), lineno=269, col_offset=4), 'run_doctest', Load(), lineno=269, col_offset=4), [Name('test_genexps', Load(), lineno=269, col_offset=29), Name('verbose', Load(), lineno=269, col_offset=43)], [], None, None, lineno=269, col_offset=4), lineno=269, col_offset=4), If(BoolOp(And(), [Name('verbose', Load(), lineno=272, col_offset=7), Call(Name('hasattr', Load(), lineno=272, col_offset=19), [Name('sys', Load(), lineno=272, col_offset=27), Str('gettotalrefcount', lineno=272, col_offset=32)], [], None, None, lineno=272, col_offset=19)], lineno=272, col_offset=7), [Import([alias('gc', None)], lineno=273, col_offset=8), Assign([Name('counts', Store(), lineno=274, col_offset=8)], BinOp(List([Name('None', Load(), lineno=274, col_offset=18)], Load(), lineno=274, col_offset=17), Mult(), Num(5, lineno=274, col_offset=26), lineno=274, col_offset=17), lineno=274, col_offset=8), For(Name('i', Store(), lineno=275, col_offset=12), Call(Name('xrange', Load(), lineno=275, col_offset=17), [Call(Name('len', Load(), lineno=275, col_offset=24), [Name('counts', Load(), lineno=275, col_offset=28)], [], None, None, lineno=275, col_offset=24)], [], None, None, lineno=275, col_offset=17), [Expr(Call(Attribute(Name('test_support', Load(), lineno=276, col_offset=12), 'run_doctest', Load(), lineno=276, col_offset=12), [Name('test_genexps', Load(), lineno=276, col_offset=37), Name('verbose', Load(), lineno=276, col_offset=51)], [], None, None, lineno=276, col_offset=12), lineno=276, col_offset=12), Expr(Call(Attribute(Name('gc', Load(), lineno=277, col_offset=12), 'collect', Load(), lineno=277, col_offset=12), [], [], None, None, lineno=277, col_offset=12), lineno=277, col_offset=12), Assign([Subscript(Name('counts', Load(), lineno=278, col_offset=12), Index(Name('i', Load(), lineno=278, col_offset=19)), Store(), lineno=278, col_offset=12)], Call(Attribute(Name('sys', Load(), lineno=278, col_offset=24), 'gettotalrefcount', Load(), lineno=278, col_offset=24), [], [], None, None, lineno=278, col_offset=24), lineno=278, col_offset=12)], [], lineno=275, col_offset=8), Print(None, [Name('counts', Load(), lineno=279, col_offset=14)], True, lineno=279, col_offset=8)], [], lineno=272, col_offset=4)], [], lineno=265, col_offset=0), If(Compare(Name('__name__', Load(), lineno=281, col_offset=3), [Eq()], [Str('__main__', lineno=281, col_offset=15)], lineno=281, col_offset=3), [Expr(Call(Name('test_main', Load(), lineno=282, col_offset=4), [], [keyword('verbose', Name('True', Load(), lineno=282, col_offset=22))], None, None, lineno=282, col_offset=4), lineno=282, col_offset=4)], [], lineno=281, col_offset=0)])
