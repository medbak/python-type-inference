Module([Expr(Str('\nTest script for doctest.\n', lineno=4, col_offset=-1), lineno=4, col_offset=-1), Import([alias('sys', None)], lineno=6, col_offset=0), ImportFrom('test', [alias('test_support', None)], 0, lineno=7, col_offset=0), Import([alias('doctest', None)], lineno=8, col_offset=0), FunctionDef('sample_func', arguments([Name('v', Param(), lineno=17, col_offset=16)], None, None, []), [Expr(Str('\n    Blah blah\n\n    >>> print sample_func(22)\n    44\n\n    Yee ha!\n    ', lineno=25, col_offset=-1), lineno=25, col_offset=-1), Return(BinOp(Name('v', Load(), lineno=26, col_offset=11), Add(), Name('v', Load(), lineno=26, col_offset=13), lineno=26, col_offset=11), lineno=26, col_offset=4)], [], lineno=17, col_offset=0), ClassDef('SampleClass', [], [Expr(Str('\n    >>> print 1\n    1\n\n    >>> # comments get ignored.  so are empty PS1 and PS2 prompts:\n    >>>\n    ...\n\n    Multiline example:\n    >>> sc = SampleClass(3)\n    >>> for i in range(10):\n    ...     sc = sc.double()\n    ...     print sc.get(),\n    6 12 24 48 96 192 384 768 1536 3072\n    ', lineno=43, col_offset=-1), lineno=43, col_offset=-1), FunctionDef('__init__', arguments([Name('self', Param(), lineno=44, col_offset=17), Name('val', Param(), lineno=44, col_offset=23)], None, None, []), [Expr(Str('\n        >>> print SampleClass(12).get()\n        12\n        ', lineno=48, col_offset=-1), lineno=48, col_offset=-1), Assign([Attribute(Name('self', Load(), lineno=49, col_offset=8), 'val', Store(), lineno=49, col_offset=8)], Name('val', Load(), lineno=49, col_offset=19), lineno=49, col_offset=8)], [], lineno=44, col_offset=4), FunctionDef('double', arguments([Name('self', Param(), lineno=51, col_offset=15)], None, None, []), [Expr(Str('\n        >>> print SampleClass(12).double().get()\n        24\n        ', lineno=55, col_offset=-1), lineno=55, col_offset=-1), Return(Call(Name('SampleClass', Load(), lineno=56, col_offset=15), [BinOp(Attribute(Name('self', Load(), lineno=56, col_offset=27), 'val', Load(), lineno=56, col_offset=27), Add(), Attribute(Name('self', Load(), lineno=56, col_offset=38), 'val', Load(), lineno=56, col_offset=38), lineno=56, col_offset=27)], [], None, None, lineno=56, col_offset=15), lineno=56, col_offset=8)], [], lineno=51, col_offset=4), FunctionDef('get', arguments([Name('self', Param(), lineno=58, col_offset=12)], None, None, []), [Expr(Str('\n        >>> print SampleClass(-5).get()\n        -5\n        ', lineno=62, col_offset=-1), lineno=62, col_offset=-1), Return(Attribute(Name('self', Load(), lineno=63, col_offset=15), 'val', Load(), lineno=63, col_offset=15), lineno=63, col_offset=8)], [], lineno=58, col_offset=4), FunctionDef('a_staticmethod', arguments([Name('v', Param(), lineno=65, col_offset=23)], None, None, []), [Expr(Str('\n        >>> print SampleClass.a_staticmethod(10)\n        11\n        ', lineno=69, col_offset=-1), lineno=69, col_offset=-1), Return(BinOp(Name('v', Load(), lineno=70, col_offset=15), Add(), Num(1, lineno=70, col_offset=17), lineno=70, col_offset=15), lineno=70, col_offset=8)], [], lineno=65, col_offset=4), Assign([Name('a_staticmethod', Store(), lineno=71, col_offset=4)], Call(Name('staticmethod', Load(), lineno=71, col_offset=21), [Name('a_staticmethod', Load(), lineno=71, col_offset=34)], [], None, None, lineno=71, col_offset=21), lineno=71, col_offset=4), FunctionDef('a_classmethod', arguments([Name('cls', Param(), lineno=73, col_offset=22), Name('v', Param(), lineno=73, col_offset=27)], None, None, []), [Expr(Str('\n        >>> print SampleClass.a_classmethod(10)\n        12\n        >>> print SampleClass(0).a_classmethod(10)\n        12\n        ', lineno=79, col_offset=-1), lineno=79, col_offset=-1), Return(BinOp(Name('v', Load(), lineno=80, col_offset=15), Add(), Num(2, lineno=80, col_offset=17), lineno=80, col_offset=15), lineno=80, col_offset=8)], [], lineno=73, col_offset=4), Assign([Name('a_classmethod', Store(), lineno=81, col_offset=4)], Call(Name('classmethod', Load(), lineno=81, col_offset=20), [Name('a_classmethod', Load(), lineno=81, col_offset=32)], [], None, None, lineno=81, col_offset=20), lineno=81, col_offset=4), Assign([Name('a_property', Store(), lineno=83, col_offset=4)], Call(Name('property', Load(), lineno=83, col_offset=17), [Name('get', Load(), lineno=83, col_offset=26)], [keyword('doc', Str('\n        >>> print SampleClass(22).a_property\n        22\n        ', lineno=86, col_offset=-1))], None, None, lineno=83, col_offset=17), lineno=83, col_offset=4), ClassDef('NestedClass', [], [Expr(Str('\n        >>> x = SampleClass.NestedClass(5)\n        >>> y = x.square()\n        >>> print y.get()\n        25\n        ', lineno=94, col_offset=-1), lineno=94, col_offset=-1), FunctionDef('__init__', arguments([Name('self', Param(), lineno=95, col_offset=21), Name('val', Param(), lineno=95, col_offset=27)], None, None, [Num(0, lineno=95, col_offset=31)]), [Expr(Str('\n            >>> print SampleClass.NestedClass().get()\n            0\n            ', lineno=99, col_offset=-1), lineno=99, col_offset=-1), Assign([Attribute(Name('self', Load(), lineno=100, col_offset=12), 'val', Store(), lineno=100, col_offset=12)], Name('val', Load(), lineno=100, col_offset=23), lineno=100, col_offset=12)], [], lineno=95, col_offset=8), FunctionDef('square', arguments([Name('self', Param(), lineno=101, col_offset=19)], None, None, []), [Return(Call(Attribute(Name('SampleClass', Load(), lineno=102, col_offset=19), 'NestedClass', Load(), lineno=102, col_offset=19), [BinOp(Attribute(Name('self', Load(), lineno=102, col_offset=43), 'val', Load(), lineno=102, col_offset=43), Mult(), Attribute(Name('self', Load(), lineno=102, col_offset=52), 'val', Load(), lineno=102, col_offset=52), lineno=102, col_offset=43)], [], None, None, lineno=102, col_offset=19), lineno=102, col_offset=12)], [], lineno=101, col_offset=8), FunctionDef('get', arguments([Name('self', Param(), lineno=103, col_offset=16)], None, None, []), [Return(Attribute(Name('self', Load(), lineno=104, col_offset=19), 'val', Load(), lineno=104, col_offset=19), lineno=104, col_offset=12)], [], lineno=103, col_offset=8)], [], lineno=88, col_offset=4)], [], lineno=28, col_offset=0), ClassDef('SampleNewStyleClass', [Name('object', Load(), lineno=106, col_offset=26)], [Expr(Str("\n    >>> print '1\\n2\\n3'\n    1\n    2\n    3\n    ", lineno=112, col_offset=-1), lineno=112, col_offset=-1), FunctionDef('__init__', arguments([Name('self', Param(), lineno=113, col_offset=17), Name('val', Param(), lineno=113, col_offset=23)], None, None, []), [Expr(Str('\n        >>> print SampleNewStyleClass(12).get()\n        12\n        ', lineno=117, col_offset=-1), lineno=117, col_offset=-1), Assign([Attribute(Name('self', Load(), lineno=118, col_offset=8), 'val', Store(), lineno=118, col_offset=8)], Name('val', Load(), lineno=118, col_offset=19), lineno=118, col_offset=8)], [], lineno=113, col_offset=4), FunctionDef('double', arguments([Name('self', Param(), lineno=120, col_offset=15)], None, None, []), [Expr(Str('\n        >>> print SampleNewStyleClass(12).double().get()\n        24\n        ', lineno=124, col_offset=-1), lineno=124, col_offset=-1), Return(Call(Name('SampleNewStyleClass', Load(), lineno=125, col_offset=15), [BinOp(Attribute(Name('self', Load(), lineno=125, col_offset=35), 'val', Load(), lineno=125, col_offset=35), Add(), Attribute(Name('self', Load(), lineno=125, col_offset=46), 'val', Load(), lineno=125, col_offset=46), lineno=125, col_offset=35)], [], None, None, lineno=125, col_offset=15), lineno=125, col_offset=8)], [], lineno=120, col_offset=4), FunctionDef('get', arguments([Name('self', Param(), lineno=127, col_offset=12)], None, None, []), [Expr(Str('\n        >>> print SampleNewStyleClass(-5).get()\n        -5\n        ', lineno=131, col_offset=-1), lineno=131, col_offset=-1), Return(Attribute(Name('self', Load(), lineno=132, col_offset=15), 'val', Load(), lineno=132, col_offset=15), lineno=132, col_offset=8)], [], lineno=127, col_offset=4)], [], lineno=106, col_offset=0), ClassDef('_FakeInput', [], [Expr(Str("\n    A fake input stream for pdb's interactive debugger.  Whenever a\n    line is read, print it (to simulate the user typing it), and then\n    return it.  The set of lines to return is specified in the\n    constructor; they should not have trailing newlines.\n    ", lineno=144, col_offset=-1), lineno=144, col_offset=-1), FunctionDef('__init__', arguments([Name('self', Param(), lineno=145, col_offset=17), Name('lines', Param(), lineno=145, col_offset=23)], None, None, []), [Assign([Attribute(Name('self', Load(), lineno=146, col_offset=8), 'lines', Store(), lineno=146, col_offset=8)], Name('lines', Load(), lineno=146, col_offset=21), lineno=146, col_offset=8)], [], lineno=145, col_offset=4), FunctionDef('readline', arguments([Name('self', Param(), lineno=148, col_offset=17)], None, None, []), [Assign([Name('line', Store(), lineno=149, col_offset=8)], Call(Attribute(Attribute(Name('self', Load(), lineno=149, col_offset=15), 'lines', Load(), lineno=149, col_offset=15), 'pop', Load(), lineno=149, col_offset=15), [Num(0, lineno=149, col_offset=30)], [], None, None, lineno=149, col_offset=15), lineno=149, col_offset=8), Print(None, [Name('line', Load(), lineno=150, col_offset=14)], True, lineno=150, col_offset=8), Return(BinOp(Name('line', Load(), lineno=151, col_offset=15), Add(), Str('\n', lineno=151, col_offset=20), lineno=151, col_offset=15), lineno=151, col_offset=8)], [], lineno=148, col_offset=4)], [], lineno=138, col_offset=0), FunctionDef('test_Example', arguments([], None, None, []), [Expr(Str('\nUnit tests for the `Example` class.\n\nExample is a simple container class that holds:\n  - `source`: A source string.\n  - `want`: An expected output string.\n  - `exc_msg`: An expected exception message string (or None if no\n    exception is expected).\n  - `lineno`: A line number (within the docstring).\n  - `indent`: The example\'s indentation in the input string.\n  - `options`: An option dictionary, mapping option flags to True or\n    False.\n\nThese attributes are set by the constructor.  `source` and `want` are\nrequired; the other attributes all have default values:\n\n    >>> example = doctest.Example(\'print 1\', \'1\\n\')\n    >>> (example.source, example.want, example.exc_msg,\n    ...  example.lineno, example.indent, example.options)\n    (\'print 1\\n\', \'1\\n\', None, 0, 0, {})\n\nThe first three attributes (`source`, `want`, and `exc_msg`) may be\nspecified positionally; the remaining arguments should be specified as\nkeyword arguments:\n\n    >>> exc_msg = \'IndexError: pop from an empty list\'\n    >>> example = doctest.Example(\'[].pop()\', \'\', exc_msg,\n    ...                           lineno=5, indent=4,\n    ...                           options={doctest.ELLIPSIS: True})\n    >>> (example.source, example.want, example.exc_msg,\n    ...  example.lineno, example.indent, example.options)\n    (\'[].pop()\\n\', \'\', \'IndexError: pop from an empty list\\n\', 5, 4, {8: True})\n\nThe constructor normalizes the `source` string to end in a newline:\n\n    Source spans a single line: no terminating newline.\n    >>> e = doctest.Example(\'print 1\', \'1\\n\')\n    >>> e.source, e.want\n    (\'print 1\\n\', \'1\\n\')\n\n    >>> e = doctest.Example(\'print 1\\n\', \'1\\n\')\n    >>> e.source, e.want\n    (\'print 1\\n\', \'1\\n\')\n\n    Source spans multiple lines: require terminating newline.\n    >>> e = doctest.Example(\'print 1;\\nprint 2\\n\', \'1\\n2\\n\')\n    >>> e.source, e.want\n    (\'print 1;\\nprint 2\\n\', \'1\\n2\\n\')\n\n    >>> e = doctest.Example(\'print 1;\\nprint 2\', \'1\\n2\\n\')\n    >>> e.source, e.want\n    (\'print 1;\\nprint 2\\n\', \'1\\n2\\n\')\n\n    Empty source string (which should never appear in real examples)\n    >>> e = doctest.Example(\'\', \'\')\n    >>> e.source, e.want\n    (\'\\n\', \'\')\n\nThe constructor normalizes the `want` string to end in a newline,\nunless it\'s the empty string:\n\n    >>> e = doctest.Example(\'print 1\', \'1\\n\')\n    >>> e.source, e.want\n    (\'print 1\\n\', \'1\\n\')\n\n    >>> e = doctest.Example(\'print 1\', \'1\')\n    >>> e.source, e.want\n    (\'print 1\\n\', \'1\\n\')\n\n    >>> e = doctest.Example(\'print\', \'\')\n    >>> e.source, e.want\n    (\'print\\n\', \'\')\n\nThe constructor normalizes the `exc_msg` string to end in a newline,\nunless it\'s `None`:\n\n    Message spans one line\n    >>> exc_msg = \'IndexError: pop from an empty list\'\n    >>> e = doctest.Example(\'[].pop()\', \'\', exc_msg)\n    >>> e.exc_msg\n    \'IndexError: pop from an empty list\\n\'\n\n    >>> exc_msg = \'IndexError: pop from an empty list\\n\'\n    >>> e = doctest.Example(\'[].pop()\', \'\', exc_msg)\n    >>> e.exc_msg\n    \'IndexError: pop from an empty list\\n\'\n\n    Message spans multiple lines\n    >>> exc_msg = \'ValueError: 1\\n  2\'\n    >>> e = doctest.Example(\'raise ValueError("1\\n  2")\', \'\', exc_msg)\n    >>> e.exc_msg\n    \'ValueError: 1\\n  2\\n\'\n\n    >>> exc_msg = \'ValueError: 1\\n  2\\n\'\n    >>> e = doctest.Example(\'raise ValueError("1\\n  2")\', \'\', exc_msg)\n    >>> e.exc_msg\n    \'ValueError: 1\\n  2\\n\'\n\n    Empty (but non-None) exception message (which should never appear\n    in real examples)\n    >>> exc_msg = \'\'\n    >>> e = doctest.Example(\'raise X()\', \'\', exc_msg)\n    >>> e.exc_msg\n    \'\\n\'\n', lineno=261, col_offset=-1), lineno=261, col_offset=-1)], [], lineno=157, col_offset=0), FunctionDef('test_DocTest', arguments([], None, None, []), [Expr(Str('\nUnit tests for the `DocTest` class.\n\nDocTest is a collection of examples, extracted from a docstring, along\nwith information about where the docstring comes from (a name,\nfilename, and line number).  The docstring is parsed by the `DocTest`\nconstructor:\n\n    >>> docstring = \'\'\'\n    ...     >>> print 12\n    ...     12\n    ...\n    ... Non-example text.\n    ...\n    ...     >>> print \'another\\example\'\n    ...     another\n    ...     example\n    ... \'\'\'\n    >>> globs = {} # globals to run the test in.\n    >>> parser = doctest.DocTestParser()\n    >>> test = parser.get_doctest(docstring, globs, \'some_test\',\n    ...                           \'some_file\', 20)\n    >>> print test\n    <DocTest some_test from some_file:20 (2 examples)>\n    >>> len(test.examples)\n    2\n    >>> e1, e2 = test.examples\n    >>> (e1.source, e1.want, e1.lineno)\n    (\'print 12\\n\', \'12\\n\', 1)\n    >>> (e2.source, e2.want, e2.lineno)\n    ("print \'another\\\\example\'\\n", \'another\\nexample\\n\', 6)\n\nSource information (name, filename, and line number) is available as\nattributes on the doctest object:\n\n    >>> (test.name, test.filename, test.lineno)\n    (\'some_test\', \'some_file\', 20)\n\nThe line number of an example within its containing file is found by\nadding the line number of the example and the line number of its\ncontaining test:\n\n    >>> test.lineno + e1.lineno\n    21\n    >>> test.lineno + e2.lineno\n    26\n\nIf the docstring contains inconsistant leading whitespace in the\nexpected output of an example, then `DocTest` will raise a ValueError:\n\n    >>> docstring = r\'\'\'\n    ...       >>> print \'bad\\nindentation\'\n    ...       bad\n    ...     indentation\n    ...     \'\'\'\n    >>> parser.get_doctest(docstring, globs, \'some_test\', \'filename\', 0)\n    Traceback (most recent call last):\n    ValueError: line 4 of the docstring for some_test has inconsistent leading whitespace: \'indentation\'\n\nIf the docstring contains inconsistent leading whitespace on\ncontinuation lines, then `DocTest` will raise a ValueError:\n\n    >>> docstring = r\'\'\'\n    ...       >>> print (\'bad indentation\',\n    ...     ...          2)\n    ...       (\'bad\', \'indentation\')\n    ...     \'\'\'\n    >>> parser.get_doctest(docstring, globs, \'some_test\', \'filename\', 0)\n    Traceback (most recent call last):\n    ValueError: line 2 of the docstring for some_test has inconsistent leading whitespace: \'...          2)\'\n\nIf there\'s no blank space after a PS1 prompt (\'>>>\'), then `DocTest`\nwill raise a ValueError:\n\n    >>> docstring = \'>>>print 1\\n1\'\n    >>> parser.get_doctest(docstring, globs, \'some_test\', \'filename\', 0)\n    Traceback (most recent call last):\n    ValueError: line 1 of the docstring for some_test lacks blank after >>>: \'>>>print 1\'\n\nIf there\'s no blank space after a PS2 prompt (\'...\'), then `DocTest`\nwill raise a ValueError:\n\n    >>> docstring = \'>>> if 1:\\n...print 1\\n1\'\n    >>> parser.get_doctest(docstring, globs, \'some_test\', \'filename\', 0)\n    Traceback (most recent call last):\n    ValueError: line 2 of the docstring for some_test lacks blank after ...: \'...print 1\'\n\n', lineno=350, col_offset=-1), lineno=350, col_offset=-1)], [], lineno=263, col_offset=0), FunctionDef('test_DocTestFinder', arguments([], None, None, []), [Expr(Str("\nUnit tests for the `DocTestFinder` class.\n\nDocTestFinder is used to extract DocTests from an object's docstring\nand the docstrings of its contained objects.  It can be used with\nmodules, functions, classes, methods, staticmethods, classmethods, and\nproperties.\n\nFinding Tests in Functions\n~~~~~~~~~~~~~~~~~~~~~~~~~~\nFor a function whose docstring contains examples, DocTestFinder.find()\nwill return a single test (for that function's docstring):\n\n    >>> finder = doctest.DocTestFinder()\n\nWe'll simulate a __file__ attr that ends in pyc:\n\n    >>> import test.test_doctest\n    >>> old = test.test_doctest.__file__\n    >>> test.test_doctest.__file__ = 'test_doctest.pyc'\n\n    >>> tests = finder.find(sample_func)\n\n    >>> print tests  # doctest: +ELLIPSIS\n    [<DocTest sample_func from ...:17 (1 example)>]\n\nThe exact name depends on how test_doctest was invoked, so allow for\nleading path components.\n\n    >>> tests[0].filename # doctest: +ELLIPSIS\n    '...test_doctest.py'\n\n    >>> test.test_doctest.__file__ = old\n\n\n    >>> e = tests[0].examples[0]\n    >>> (e.source, e.want, e.lineno)\n    ('print sample_func(22)\\n', '44\\n', 3)\n\nBy default, tests are created for objects with no docstring:\n\n    >>> def no_docstring(v):\n    ...     pass\n    >>> finder.find(no_docstring)\n    []\n\nHowever, the optional argument `exclude_empty` to the DocTestFinder\nconstructor can be used to exclude tests for objects with empty\ndocstrings:\n\n    >>> def no_docstring(v):\n    ...     pass\n    >>> excl_empty_finder = doctest.DocTestFinder(exclude_empty=True)\n    >>> excl_empty_finder.find(no_docstring)\n    []\n\nIf the function has a docstring with no examples, then a test with no\nexamples is returned.  (This lets `DocTestRunner` collect statistics\nabout which functions have no tests -- but is that useful?  And should\nan empty test also be created when there's no docstring?)\n\n    >>> def no_examples(v):\n    ...     ''' no doctest examples '''\n    >>> finder.find(no_examples) # doctest: +ELLIPSIS\n    [<DocTest no_examples from ...:1 (no examples)>]\n\nFinding Tests in Classes\n~~~~~~~~~~~~~~~~~~~~~~~~\nFor a class, DocTestFinder will create a test for the class's\ndocstring, and will recursively explore its contents, including\nmethods, classmethods, staticmethods, properties, and nested classes.\n\n    >>> finder = doctest.DocTestFinder()\n    >>> tests = finder.find(SampleClass)\n    >>> for t in tests:\n    ...     print '%2s  %s' % (len(t.examples), t.name)\n     3  SampleClass\n     3  SampleClass.NestedClass\n     1  SampleClass.NestedClass.__init__\n     1  SampleClass.__init__\n     2  SampleClass.a_classmethod\n     1  SampleClass.a_property\n     1  SampleClass.a_staticmethod\n     1  SampleClass.double\n     1  SampleClass.get\n\nNew-style classes are also supported:\n\n    >>> tests = finder.find(SampleNewStyleClass)\n    >>> for t in tests:\n    ...     print '%2s  %s' % (len(t.examples), t.name)\n     1  SampleNewStyleClass\n     1  SampleNewStyleClass.__init__\n     1  SampleNewStyleClass.double\n     1  SampleNewStyleClass.get\n\nFinding Tests in Modules\n~~~~~~~~~~~~~~~~~~~~~~~~\nFor a module, DocTestFinder will create a test for the class's\ndocstring, and will recursively explore its contents, including\nfunctions, classes, and the `__test__` dictionary, if it exists:\n\n    >>> # A module\n    >>> import types\n    >>> m = types.ModuleType('some_module')\n    >>> def triple(val):\n    ...     '''\n    ...     >>> print triple(11)\n    ...     33\n    ...     '''\n    ...     return val*3\n    >>> m.__dict__.update({\n    ...     'sample_func': sample_func,\n    ...     'SampleClass': SampleClass,\n    ...     '__doc__': '''\n    ...         Module docstring.\n    ...             >>> print 'module'\n    ...             module\n    ...         ''',\n    ...     '__test__': {\n    ...         'd': '>>> print 6\\n6\\n>>> print 7\\n7\\n',\n    ...         'c': triple}})\n\n    >>> finder = doctest.DocTestFinder()\n    >>> # Use module=test.test_doctest, to prevent doctest from\n    >>> # ignoring the objects since they weren't defined in m.\n    >>> import test.test_doctest\n    >>> tests = finder.find(m, module=test.test_doctest)\n    >>> for t in tests:\n    ...     print '%2s  %s' % (len(t.examples), t.name)\n     1  some_module\n     3  some_module.SampleClass\n     3  some_module.SampleClass.NestedClass\n     1  some_module.SampleClass.NestedClass.__init__\n     1  some_module.SampleClass.__init__\n     2  some_module.SampleClass.a_classmethod\n     1  some_module.SampleClass.a_property\n     1  some_module.SampleClass.a_staticmethod\n     1  some_module.SampleClass.double\n     1  some_module.SampleClass.get\n     1  some_module.__test__.c\n     2  some_module.__test__.d\n     1  some_module.sample_func\n\nDuplicate Removal\n~~~~~~~~~~~~~~~~~\nIf a single object is listed twice (under different names), then tests\nwill only be generated for it once:\n\n    >>> from test import doctest_aliases\n    >>> assert doctest_aliases.TwoNames.f\n    >>> assert doctest_aliases.TwoNames.g\n    >>> tests = excl_empty_finder.find(doctest_aliases)\n    >>> print len(tests)\n    2\n    >>> print tests[0].name\n    test.doctest_aliases.TwoNames\n\n    TwoNames.f and TwoNames.g are bound to the same object.\n    We can't guess which will be found in doctest's traversal of\n    TwoNames.__dict__ first, so we have to allow for either.\n\n    >>> tests[1].name.split('.')[-1] in ['f', 'g']\n    True\n\nEmpty Tests\n~~~~~~~~~~~\nBy default, an object with no doctests doesn't create any tests:\n\n    >>> tests = doctest.DocTestFinder().find(SampleClass)\n    >>> for t in tests:\n    ...     print '%2s  %s' % (len(t.examples), t.name)\n     3  SampleClass\n     3  SampleClass.NestedClass\n     1  SampleClass.NestedClass.__init__\n     1  SampleClass.__init__\n     2  SampleClass.a_classmethod\n     1  SampleClass.a_property\n     1  SampleClass.a_staticmethod\n     1  SampleClass.double\n     1  SampleClass.get\n\nBy default, that excluded objects with no doctests.  exclude_empty=False\ntells it to include (empty) tests for objects with no doctests.  This feature\nis really to support backward compatibility in what doctest.master.summarize()\ndisplays.\n\n    >>> tests = doctest.DocTestFinder(exclude_empty=False).find(SampleClass)\n    >>> for t in tests:\n    ...     print '%2s  %s' % (len(t.examples), t.name)\n     3  SampleClass\n     3  SampleClass.NestedClass\n     1  SampleClass.NestedClass.__init__\n     0  SampleClass.NestedClass.get\n     0  SampleClass.NestedClass.square\n     1  SampleClass.__init__\n     2  SampleClass.a_classmethod\n     1  SampleClass.a_property\n     1  SampleClass.a_staticmethod\n     1  SampleClass.double\n     1  SampleClass.get\n\nTurning off Recursion\n~~~~~~~~~~~~~~~~~~~~~\nDocTestFinder can be told not to look for tests in contained objects\nusing the `recurse` flag:\n\n    >>> tests = doctest.DocTestFinder(recurse=False).find(SampleClass)\n    >>> for t in tests:\n    ...     print '%2s  %s' % (len(t.examples), t.name)\n     3  SampleClass\n\nLine numbers\n~~~~~~~~~~~~\nDocTestFinder finds the line number of each example:\n\n    >>> def f(x):\n    ...     '''\n    ...     >>> x = 12\n    ...\n    ...     some text\n    ...\n    ...     >>> # examples are not created for comments & bare prompts.\n    ...     >>>\n    ...     ...\n    ...\n    ...     >>> for x in range(10):\n    ...     ...     print x,\n    ...     0 1 2 3 4 5 6 7 8 9\n    ...     >>> x//2\n    ...     6\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> [e.lineno for e in test.examples]\n    [1, 9, 12]\n", lineno=587, col_offset=-1), lineno=587, col_offset=-1)], [], lineno=352, col_offset=0), FunctionDef('test_DocTestParser', arguments([], None, None, []), [Expr(Str("\nUnit tests for the `DocTestParser` class.\n\nDocTestParser is used to parse docstrings containing doctest examples.\n\nThe `parse` method divides a docstring into examples and intervening\ntext:\n\n    >>> s = '''\n    ...     >>> x, y = 2, 3  # no output expected\n    ...     >>> if 1:\n    ...     ...     print x\n    ...     ...     print y\n    ...     2\n    ...     3\n    ...\n    ...     Some text.\n    ...     >>> x+y\n    ...     5\n    ...     '''\n    >>> parser = doctest.DocTestParser()\n    >>> for piece in parser.parse(s):\n    ...     if isinstance(piece, doctest.Example):\n    ...         print 'Example:', (piece.source, piece.want, piece.lineno)\n    ...     else:\n    ...         print '   Text:', `piece`\n       Text: '\\n'\n    Example: ('x, y = 2, 3  # no output expected\\n', '', 1)\n       Text: ''\n    Example: ('if 1:\\n    print x\\n    print y\\n', '2\\n3\\n', 2)\n       Text: '\\nSome text.\\n'\n    Example: ('x+y\\n', '5\\n', 9)\n       Text: ''\n\nThe `get_examples` method returns just the examples:\n\n    >>> for piece in parser.get_examples(s):\n    ...     print (piece.source, piece.want, piece.lineno)\n    ('x, y = 2, 3  # no output expected\\n', '', 1)\n    ('if 1:\\n    print x\\n    print y\\n', '2\\n3\\n', 2)\n    ('x+y\\n', '5\\n', 9)\n\nThe `get_doctest` method creates a Test from the examples, along with the\ngiven arguments:\n\n    >>> test = parser.get_doctest(s, {}, 'name', 'filename', lineno=5)\n    >>> (test.name, test.filename, test.lineno)\n    ('name', 'filename', 5)\n    >>> for piece in test.examples:\n    ...     print (piece.source, piece.want, piece.lineno)\n    ('x, y = 2, 3  # no output expected\\n', '', 1)\n    ('if 1:\\n    print x\\n    print y\\n', '2\\n3\\n', 2)\n    ('x+y\\n', '5\\n', 9)\n", lineno=642, col_offset=-1), lineno=642, col_offset=-1)], [], lineno=589, col_offset=0), ClassDef('test_DocTestRunner', [], [FunctionDef('basics', arguments([], None, None, []), [Expr(Str("\nUnit tests for the `DocTestRunner` class.\n\nDocTestRunner is used to run DocTest test cases, and to accumulate\nstatistics.  Here's a simple DocTest case we can use:\n\n    >>> def f(x):\n    ...     '''\n    ...     >>> x = 12\n    ...     >>> print x\n    ...     12\n    ...     >>> x//2\n    ...     6\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n\nThe main DocTestRunner interface is the `run` method, which runs a\ngiven DocTest case in a given namespace (globs).  It returns a tuple\n`(f,t)`, where `f` is the number of failed tests and `t` is the number\nof tried tests.\n\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=3)\n\nIf any example produces incorrect output, then the test runner reports\nthe failure and proceeds to the next example:\n\n    >>> def f(x):\n    ...     '''\n    ...     >>> x = 12\n    ...     >>> print x\n    ...     14\n    ...     >>> x//2\n    ...     6\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=True).run(test)\n    ... # doctest: +ELLIPSIS\n    Trying:\n        x = 12\n    Expecting nothing\n    ok\n    Trying:\n        print x\n    Expecting:\n        14\n    **********************************************************************\n    File ..., line 4, in f\n    Failed example:\n        print x\n    Expected:\n        14\n    Got:\n        12\n    Trying:\n        x//2\n    Expecting:\n        6\n    ok\n    TestResults(failed=1, attempted=3)\n", lineno=705, col_offset=-1), lineno=705, col_offset=-1)], [], lineno=645, col_offset=4), FunctionDef('verbose_flag', arguments([], None, None, []), [Expr(Str("\nThe `verbose` flag makes the test runner generate more detailed\noutput:\n\n    >>> def f(x):\n    ...     '''\n    ...     >>> x = 12\n    ...     >>> print x\n    ...     12\n    ...     >>> x//2\n    ...     6\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n\n    >>> doctest.DocTestRunner(verbose=True).run(test)\n    Trying:\n        x = 12\n    Expecting nothing\n    ok\n    Trying:\n        print x\n    Expecting:\n        12\n    ok\n    Trying:\n        x//2\n    Expecting:\n        6\n    ok\n    TestResults(failed=0, attempted=3)\n\nIf the `verbose` flag is unspecified, then the output will be verbose\niff `-v` appears in sys.argv:\n\n    >>> # Save the real sys.argv list.\n    >>> old_argv = sys.argv\n\n    >>> # If -v does not appear in sys.argv, then output isn't verbose.\n    >>> sys.argv = ['test']\n    >>> doctest.DocTestRunner().run(test)\n    TestResults(failed=0, attempted=3)\n\n    >>> # If -v does appear in sys.argv, then output is verbose.\n    >>> sys.argv = ['test', '-v']\n    >>> doctest.DocTestRunner().run(test)\n    Trying:\n        x = 12\n    Expecting nothing\n    ok\n    Trying:\n        print x\n    Expecting:\n        12\n    ok\n    Trying:\n        x//2\n    Expecting:\n        6\n    ok\n    TestResults(failed=0, attempted=3)\n\n    >>> # Restore sys.argv\n    >>> sys.argv = old_argv\n\nIn the remaining examples, the test runner's verbosity will be\nexplicitly set, to ensure that the test behavior is consistent.\n    ", lineno=772, col_offset=-1), lineno=772, col_offset=-1)], [], lineno=706, col_offset=4), FunctionDef('exceptions', arguments([], None, None, []), [Expr(Str("\nTests of `DocTestRunner`'s exception handling.\n\nAn expected exception is specified with a traceback message.  The\nlines between the first line and the type/value may be omitted or\nreplaced with any other string:\n\n    >>> def f(x):\n    ...     '''\n    ...     >>> x = 12\n    ...     >>> print x//0\n    ...     Traceback (most recent call last):\n    ...     ZeroDivisionError: integer division or modulo by zero\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=2)\n\nAn example may not generate output before it raises an exception; if\nit does, then the traceback message will not be recognized as\nsignaling an expected exception, so the example will be reported as an\nunexpected exception:\n\n    >>> def f(x):\n    ...     '''\n    ...     >>> x = 12\n    ...     >>> print 'pre-exception output', x//0\n    ...     pre-exception output\n    ...     Traceback (most recent call last):\n    ...     ZeroDivisionError: integer division or modulo by zero\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 4, in f\n    Failed example:\n        print 'pre-exception output', x//0\n    Exception raised:\n        ...\n        ZeroDivisionError: integer division or modulo by zero\n    TestResults(failed=1, attempted=2)\n\nException messages may contain newlines:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> raise ValueError, 'multi\\nline\\nmessage'\n    ...     Traceback (most recent call last):\n    ...     ValueError: multi\n    ...     line\n    ...     message\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=1)\n\nIf an exception is expected, but an exception with the wrong type or\nmessage is raised, then it is reported as a failure:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> raise ValueError, 'message'\n    ...     Traceback (most recent call last):\n    ...     ValueError: wrong message\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        raise ValueError, 'message'\n    Expected:\n        Traceback (most recent call last):\n        ValueError: wrong message\n    Got:\n        Traceback (most recent call last):\n        ...\n        ValueError: message\n    TestResults(failed=1, attempted=1)\n\nHowever, IGNORE_EXCEPTION_DETAIL can be used to allow a mismatch in the\ndetail:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> raise ValueError, 'message' #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...     Traceback (most recent call last):\n    ...     ValueError: wrong message\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=1)\n\nIGNORE_EXCEPTION_DETAIL also ignores difference in exception formatting\nbetween Python versions. For example, in Python 3.x, the module path of\nthe exception is in the output, but this will fail under Python 2:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> from httplib import HTTPException\n    ...     >>> raise HTTPException('message')\n    ...     Traceback (most recent call last):\n    ...     httplib.HTTPException: message\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 4, in f\n    Failed example:\n        raise HTTPException('message')\n    Expected:\n        Traceback (most recent call last):\n        httplib.HTTPException: message\n    Got:\n        Traceback (most recent call last):\n        ...\n        HTTPException: message\n    TestResults(failed=1, attempted=2)\n\nBut in Python 2 the module path is not included, an therefore a test must look\nlike the following test to succeed in Python 2. But that test will fail under\nPython 3.\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> from httplib import HTTPException\n    ...     >>> raise HTTPException('message')\n    ...     Traceback (most recent call last):\n    ...     HTTPException: message\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=2)\n\nHowever, with IGNORE_EXCEPTION_DETAIL, the module name of the exception\n(if any) will be ignored:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> from httplib import HTTPException\n    ...     >>> raise HTTPException('message') #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...     Traceback (most recent call last):\n    ...     HTTPException: message\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=2)\n\nThe module path will be completely ignored, so two different module paths will\nstill pass if IGNORE_EXCEPTION_DETAIL is given. This is intentional, so it can\nbe used when exceptions have changed module.\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> from httplib import HTTPException\n    ...     >>> raise HTTPException('message') #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...     Traceback (most recent call last):\n    ...     foo.bar.HTTPException: message\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=2)\n\nBut IGNORE_EXCEPTION_DETAIL does not allow a mismatch in the exception type:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> raise ValueError, 'message' #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...     Traceback (most recent call last):\n    ...     TypeError: wrong type\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        raise ValueError, 'message' #doctest: +IGNORE_EXCEPTION_DETAIL\n    Expected:\n        Traceback (most recent call last):\n        TypeError: wrong type\n    Got:\n        Traceback (most recent call last):\n        ...\n        ValueError: message\n    TestResults(failed=1, attempted=1)\n\nIf an exception is raised but not expected, then it is reported as an\nunexpected exception:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> 1//0\n    ...     0\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        1//0\n    Exception raised:\n        Traceback (most recent call last):\n        ...\n        ZeroDivisionError: integer division or modulo by zero\n    TestResults(failed=1, attempted=1)\n", lineno=983, col_offset=-1), lineno=983, col_offset=-1)], [], lineno=773, col_offset=4), FunctionDef('displayhook', arguments([], None, None, []), [Expr(Str("\nTest that changing sys.displayhook doesn't matter for doctest.\n\n    >>> import sys\n    >>> orig_displayhook = sys.displayhook\n    >>> def my_displayhook(x):\n    ...     print('hi!')\n    >>> sys.displayhook = my_displayhook\n    >>> def f():\n    ...     '''\n    ...     >>> 3\n    ...     3\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> r = doctest.DocTestRunner(verbose=False).run(test)\n    >>> post_displayhook = sys.displayhook\n\n    We need to restore sys.displayhook now, so that we'll be able to test\n    results.\n\n    >>> sys.displayhook = orig_displayhook\n\n    Ok, now we can check that everything is ok.\n\n    >>> r\n    TestResults(failed=0, attempted=1)\n    >>> post_displayhook is my_displayhook\n    True\n", lineno=1012, col_offset=-1), lineno=1012, col_offset=-1)], [], lineno=984, col_offset=4), FunctionDef('optionflags', arguments([], None, None, []), [Expr(Str('\nTests of `DocTestRunner`\'s option flag handling.\n\nSeveral option flags can be used to customize the behavior of the test\nrunner.  These are defined as module constants in doctest, and passed\nto the DocTestRunner constructor (multiple constants should be ORed\ntogether).\n\nThe DONT_ACCEPT_TRUE_FOR_1 flag disables matches between True/False\nand 1/0:\n\n    >>> def f(x):\n    ...     \'>>> True\\n1\\n\'\n\n    >>> # Without the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=1)\n\n    >>> # With the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.DONT_ACCEPT_TRUE_FOR_1\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        True\n    Expected:\n        1\n    Got:\n        True\n    TestResults(failed=1, attempted=1)\n\nThe DONT_ACCEPT_BLANKLINE flag disables the match between blank lines\nand the \'<BLANKLINE>\' marker:\n\n    >>> def f(x):\n    ...     \'>>> print "a\\\\n\\\\nb"\\na\\n<BLANKLINE>\\nb\\n\'\n\n    >>> # Without the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=1)\n\n    >>> # With the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.DONT_ACCEPT_BLANKLINE\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print "a\\n\\nb"\n    Expected:\n        a\n        <BLANKLINE>\n        b\n    Got:\n        a\n    <BLANKLINE>\n        b\n    TestResults(failed=1, attempted=1)\n\nThe NORMALIZE_WHITESPACE flag causes all sequences of whitespace to be\ntreated as equal:\n\n    >>> def f(x):\n    ...     \'>>> print 1, 2, 3\\n  1   2\\n 3\'\n\n    >>> # Without the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print 1, 2, 3\n    Expected:\n          1   2\n         3\n    Got:\n        1 2 3\n    TestResults(failed=1, attempted=1)\n\n    >>> # With the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.NORMALIZE_WHITESPACE\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    TestResults(failed=0, attempted=1)\n\n    An example from the docs:\n    >>> print range(20) #doctest: +NORMALIZE_WHITESPACE\n    [0,   1,  2,  3,  4,  5,  6,  7,  8,  9,\n    10,  11, 12, 13, 14, 15, 16, 17, 18, 19]\n\nThe ELLIPSIS flag causes ellipsis marker ("...") in the expected\noutput to match any substring in the actual output:\n\n    >>> def f(x):\n    ...     \'>>> print range(15)\\n[0, 1, 2, ..., 14]\\n\'\n\n    >>> # Without the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print range(15)\n    Expected:\n        [0, 1, 2, ..., 14]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n    TestResults(failed=1, attempted=1)\n\n    >>> # With the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.ELLIPSIS\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    TestResults(failed=0, attempted=1)\n\n    ... also matches nothing:\n\n    >>> for i in range(100):\n    ...     print i**2, #doctest: +ELLIPSIS\n    0 1...4...9 16 ... 36 49 64 ... 9801\n\n    ... can be surprising; e.g., this test passes:\n\n    >>> for i in range(21): #doctest: +ELLIPSIS\n    ...     print i,\n    0 1 2 ...1...2...0\n\n    Examples from the docs:\n\n    >>> print range(20) # doctest:+ELLIPSIS\n    [0, 1, ..., 18, 19]\n\n    >>> print range(20) # doctest: +ELLIPSIS\n    ...                 # doctest: +NORMALIZE_WHITESPACE\n    [0,    1, ...,   18,    19]\n\nThe SKIP flag causes an example to be skipped entirely.  I.e., the\nexample is not run.  It can be useful in contexts where doctest\nexamples serve as both documentation and test cases, and an example\nshould be included for documentation purposes, but should not be\nchecked (e.g., because its output is random, or depends on resources\nwhich would be unavailable.)  The SKIP flag can also be used for\n\'commenting out\' broken examples.\n\n    >>> import unavailable_resource           # doctest: +SKIP\n    >>> unavailable_resource.do_something()   # doctest: +SKIP\n    >>> unavailable_resource.blow_up()        # doctest: +SKIP\n    Traceback (most recent call last):\n        ...\n    UncheckedBlowUpError:  Nobody checks me.\n\n    >>> import random\n    >>> print random.random() # doctest: +SKIP\n    0.721216923889\n\nThe REPORT_UDIFF flag causes failures that involve multi-line expected\nand actual outputs to be displayed using a unified diff:\n\n    >>> def f(x):\n    ...     r\'\'\'\n    ...     >>> print \'\\n\'.join(\'abcdefg\')\n    ...     a\n    ...     B\n    ...     c\n    ...     d\n    ...     f\n    ...     g\n    ...     h\n    ...     \'\'\'\n\n    >>> # Without the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        print \'\\n\'.join(\'abcdefg\')\n    Expected:\n        a\n        B\n        c\n        d\n        f\n        g\n        h\n    Got:\n        a\n        b\n        c\n        d\n        e\n        f\n        g\n    TestResults(failed=1, attempted=1)\n\n    >>> # With the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.REPORT_UDIFF\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        print \'\\n\'.join(\'abcdefg\')\n    Differences (unified diff with -expected +actual):\n        @@ -1,7 +1,7 @@\n         a\n        -B\n        +b\n         c\n         d\n        +e\n         f\n         g\n        -h\n    TestResults(failed=1, attempted=1)\n\nThe REPORT_CDIFF flag causes failures that involve multi-line expected\nand actual outputs to be displayed using a context diff:\n\n    >>> # Reuse f() from the REPORT_UDIFF example, above.\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.REPORT_CDIFF\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        print \'\\n\'.join(\'abcdefg\')\n    Differences (context diff with expected followed by actual):\n        ***************\n        *** 1,7 ****\n          a\n        ! B\n          c\n          d\n          f\n          g\n        - h\n        --- 1,7 ----\n          a\n        ! b\n          c\n          d\n        + e\n          f\n          g\n    TestResults(failed=1, attempted=1)\n\n\nThe REPORT_NDIFF flag causes failures to use the difflib.Differ algorithm\nused by the popular ndiff.py utility.  This does intraline difference\nmarking, as well as interline differences.\n\n    >>> def f(x):\n    ...     r\'\'\'\n    ...     >>> print "a b  c d e f g h i   j k l m"\n    ...     a b c d e f g h i j k 1 m\n    ...     \'\'\'\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.REPORT_NDIFF\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        print "a b  c d e f g h i   j k l m"\n    Differences (ndiff with -expected +actual):\n        - a b c d e f g h i j k 1 m\n        ?                       ^\n        + a b  c d e f g h i   j k l m\n        ?     +              ++    ^\n    TestResults(failed=1, attempted=1)\n\nThe REPORT_ONLY_FIRST_FAILURE supresses result output after the first\nfailing example:\n\n    >>> def f(x):\n    ...     r\'\'\'\n    ...     >>> print 1 # first success\n    ...     1\n    ...     >>> print 2 # first failure\n    ...     200\n    ...     >>> print 3 # second failure\n    ...     300\n    ...     >>> print 4 # second success\n    ...     4\n    ...     >>> print 5 # third failure\n    ...     500\n    ...     \'\'\'\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.REPORT_ONLY_FIRST_FAILURE\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 5, in f\n    Failed example:\n        print 2 # first failure\n    Expected:\n        200\n    Got:\n        2\n    TestResults(failed=3, attempted=5)\n\nHowever, output from `report_start` is not supressed:\n\n    >>> doctest.DocTestRunner(verbose=True, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    Trying:\n        print 1 # first success\n    Expecting:\n        1\n    ok\n    Trying:\n        print 2 # first failure\n    Expecting:\n        200\n    **********************************************************************\n    File ..., line 5, in f\n    Failed example:\n        print 2 # first failure\n    Expected:\n        200\n    Got:\n        2\n    TestResults(failed=3, attempted=5)\n\nFor the purposes of REPORT_ONLY_FIRST_FAILURE, unexpected exceptions\ncount as failures:\n\n    >>> def f(x):\n    ...     r\'\'\'\n    ...     >>> print 1 # first success\n    ...     1\n    ...     >>> raise ValueError(2) # first failure\n    ...     200\n    ...     >>> print 3 # second failure\n    ...     300\n    ...     >>> print 4 # second success\n    ...     4\n    ...     >>> print 5 # third failure\n    ...     500\n    ...     \'\'\'\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.REPORT_ONLY_FIRST_FAILURE\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 5, in f\n    Failed example:\n        raise ValueError(2) # first failure\n    Exception raised:\n        ...\n        ValueError: 2\n    TestResults(failed=3, attempted=5)\n\nNew option flags can also be registered, via register_optionflag().  Here\nwe reach into doctest\'s internals a bit.\n\n    >>> unlikely = "UNLIKELY_OPTION_NAME"\n    >>> unlikely in doctest.OPTIONFLAGS_BY_NAME\n    False\n    >>> new_flag_value = doctest.register_optionflag(unlikely)\n    >>> unlikely in doctest.OPTIONFLAGS_BY_NAME\n    True\n\nBefore 2.4.4/2.5, registering a name more than once erroneously created\nmore than one flag value.  Here we verify that\'s fixed:\n\n    >>> redundant_flag_value = doctest.register_optionflag(unlikely)\n    >>> redundant_flag_value == new_flag_value\n    True\n\nClean up.\n    >>> del doctest.OPTIONFLAGS_BY_NAME[unlikely]\n\n    ', lineno=1397, col_offset=-1), lineno=1397, col_offset=-1)], [], lineno=1013, col_offset=4), FunctionDef('option_directives', arguments([], None, None, []), [Expr(Str("\nTests of `DocTestRunner`'s option directive mechanism.\n\nOption directives can be used to turn option flags on or off for a\nsingle example.  To turn an option on for an example, follow that\nexample with a comment of the form ``# doctest: +OPTION``:\n\n    >>> def f(x): r'''\n    ...     >>> print range(10)       # should fail: no ellipsis\n    ...     [0, 1, ..., 9]\n    ...\n    ...     >>> print range(10)       # doctest: +ELLIPSIS\n    ...     [0, 1, ..., 9]\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print range(10)       # should fail: no ellipsis\n    Expected:\n        [0, 1, ..., 9]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    TestResults(failed=1, attempted=2)\n\nTo turn an option off for an example, follow that example with a\ncomment of the form ``# doctest: -OPTION``:\n\n    >>> def f(x): r'''\n    ...     >>> print range(10)\n    ...     [0, 1, ..., 9]\n    ...\n    ...     >>> # should fail: no ellipsis\n    ...     >>> print range(10)       # doctest: -ELLIPSIS\n    ...     [0, 1, ..., 9]\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False,\n    ...                       optionflags=doctest.ELLIPSIS).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 6, in f\n    Failed example:\n        print range(10)       # doctest: -ELLIPSIS\n    Expected:\n        [0, 1, ..., 9]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    TestResults(failed=1, attempted=2)\n\nOption directives affect only the example that they appear with; they\ndo not change the options for surrounding examples:\n\n    >>> def f(x): r'''\n    ...     >>> print range(10)       # Should fail: no ellipsis\n    ...     [0, 1, ..., 9]\n    ...\n    ...     >>> print range(10)       # doctest: +ELLIPSIS\n    ...     [0, 1, ..., 9]\n    ...\n    ...     >>> print range(10)       # Should fail: no ellipsis\n    ...     [0, 1, ..., 9]\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print range(10)       # Should fail: no ellipsis\n    Expected:\n        [0, 1, ..., 9]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    **********************************************************************\n    File ..., line 8, in f\n    Failed example:\n        print range(10)       # Should fail: no ellipsis\n    Expected:\n        [0, 1, ..., 9]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    TestResults(failed=2, attempted=3)\n\nMultiple options may be modified by a single option directive.  They\nmay be separated by whitespace, commas, or both:\n\n    >>> def f(x): r'''\n    ...     >>> print range(10)       # Should fail\n    ...     [0, 1,  ...,   9]\n    ...     >>> print range(10)       # Should succeed\n    ...     ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\n    ...     [0, 1,  ...,   9]\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print range(10)       # Should fail\n    Expected:\n        [0, 1,  ...,   9]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    TestResults(failed=1, attempted=2)\n\n    >>> def f(x): r'''\n    ...     >>> print range(10)       # Should fail\n    ...     [0, 1,  ...,   9]\n    ...     >>> print range(10)       # Should succeed\n    ...     ... # doctest: +ELLIPSIS,+NORMALIZE_WHITESPACE\n    ...     [0, 1,  ...,   9]\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print range(10)       # Should fail\n    Expected:\n        [0, 1,  ...,   9]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    TestResults(failed=1, attempted=2)\n\n    >>> def f(x): r'''\n    ...     >>> print range(10)       # Should fail\n    ...     [0, 1,  ...,   9]\n    ...     >>> print range(10)       # Should succeed\n    ...     ... # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE\n    ...     [0, 1,  ...,   9]\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print range(10)       # Should fail\n    Expected:\n        [0, 1,  ...,   9]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    TestResults(failed=1, attempted=2)\n\nThe option directive may be put on the line following the source, as\nlong as a continuation prompt is used:\n\n    >>> def f(x): r'''\n    ...     >>> print range(10)\n    ...     ... # doctest: +ELLIPSIS\n    ...     [0, 1, ..., 9]\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=1)\n\nFor examples with multi-line source, the option directive may appear\nat the end of any line:\n\n    >>> def f(x): r'''\n    ...     >>> for x in range(10): # doctest: +ELLIPSIS\n    ...     ...     print x,\n    ...     0 1 2 ... 9\n    ...\n    ...     >>> for x in range(10):\n    ...     ...     print x,        # doctest: +ELLIPSIS\n    ...     0 1 2 ... 9\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=2)\n\nIf more than one line of an example with multi-line source has an\noption directive, then they are combined:\n\n    >>> def f(x): r'''\n    ...     Should fail (option directive not on the last line):\n    ...         >>> for x in range(10): # doctest: +ELLIPSIS\n    ...         ...     print x,        # doctest: +NORMALIZE_WHITESPACE\n    ...         0  1    2...9\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=1)\n\nIt is an error to have a comment of the form ``# doctest:`` that is\n*not* followed by words of the form ``+OPTION`` or ``-OPTION``, where\n``OPTION`` is an option that has been registered with\n`register_option`:\n\n    >>> # Error: Option not registered\n    >>> s = '>>> print 12   #doctest: +BADOPTION'\n    >>> test = doctest.DocTestParser().get_doctest(s, {}, 's', 's.py', 0)\n    Traceback (most recent call last):\n    ValueError: line 1 of the doctest for s has an invalid option: '+BADOPTION'\n\n    >>> # Error: No + or - prefix\n    >>> s = '>>> print 12   #doctest: ELLIPSIS'\n    >>> test = doctest.DocTestParser().get_doctest(s, {}, 's', 's.py', 0)\n    Traceback (most recent call last):\n    ValueError: line 1 of the doctest for s has an invalid option: 'ELLIPSIS'\n\nIt is an error to use an option directive on a line that contains no\nsource:\n\n    >>> s = '>>> # doctest: +ELLIPSIS'\n    >>> test = doctest.DocTestParser().get_doctest(s, {}, 's', 's.py', 0)\n    Traceback (most recent call last):\n    ValueError: line 0 of the doctest for s has an option directive on a line with no example: '# doctest: +ELLIPSIS'\n\n    ", lineno=1614, col_offset=-1), lineno=1614, col_offset=-1)], [], lineno=1399, col_offset=4), FunctionDef('test_unicode_output', arguments([Name('self', Param(), lineno=1616, col_offset=28)], None, None, []), [Expr(Str("\n\nCheck that unicode output works:\n\n    >>> u'\\xe9'\n    u'\\xe9'\n\nIf we return unicode, SpoofOut's buf variable becomes automagically\nconverted to unicode. This means all subsequent output becomes converted\nto unicode, and if the output contains non-ascii characters that failed.\nIt used to be that this state change carried on between tests, meaning\ntests would fail if unicode has been output previously in the testrun.\nThis test tests that this is no longer so:\n\n    >>> print u'abc'\n    abc\n\nAnd then return a string with non-ascii characters:\n\n    >>> print u'\\xe9'.encode('utf-8')\n    \xc3\xa9\n\n    ", lineno=1638, col_offset=-1), lineno=1638, col_offset=-1)], [], lineno=1616, col_offset=4)], [], lineno=644, col_offset=0), FunctionDef('test_testsource', arguments([], None, None, []), [Expr(Str("\nUnit tests for `testsource()`.\n\nThe testsource() function takes a module and a name, finds the (first)\ntest with that name in that module, and converts it to a script. The\nexample code is converted to regular Python code.  The surrounding\nwords and expected output are converted to comments:\n\n    >>> import test.test_doctest\n    >>> name = 'test.test_doctest.sample_func'\n    >>> print doctest.testsource(test.test_doctest, name)\n    # Blah blah\n    #\n    print sample_func(22)\n    # Expected:\n    ## 44\n    #\n    # Yee ha!\n    <BLANKLINE>\n\n    >>> name = 'test.test_doctest.SampleNewStyleClass'\n    >>> print doctest.testsource(test.test_doctest, name)\n    print '1\\n2\\n3'\n    # Expected:\n    ## 1\n    ## 2\n    ## 3\n    <BLANKLINE>\n\n    >>> name = 'test.test_doctest.SampleClass.a_classmethod'\n    >>> print doctest.testsource(test.test_doctest, name)\n    print SampleClass.a_classmethod(10)\n    # Expected:\n    ## 12\n    print SampleClass(0).a_classmethod(10)\n    # Expected:\n    ## 12\n    <BLANKLINE>\n", lineno=1679, col_offset=-1), lineno=1679, col_offset=-1)], [], lineno=1641, col_offset=0), FunctionDef('test_debug', arguments([], None, None, []), [Expr(Str("\n\nCreate a docstring that we want to debug:\n\n    >>> s = '''\n    ...     >>> x = 12\n    ...     >>> print x\n    ...     12\n    ...     '''\n\nCreate some fake stdin input, to feed to the debugger:\n\n    >>> import tempfile\n    >>> real_stdin = sys.stdin\n    >>> sys.stdin = _FakeInput(['next', 'print x', 'continue'])\n\nRun the debugger on the docstring, and then restore sys.stdin.\n\n    >>> try: doctest.debug_src(s)\n    ... finally: sys.stdin = real_stdin\n    > <string>(1)<module>()\n    (Pdb) next\n    12\n    --Return--\n    > <string>(1)<module>()->None\n    (Pdb) print x\n    12\n    (Pdb) continue\n\n", lineno=1710, col_offset=-1), lineno=1710, col_offset=-1)], [], lineno=1681, col_offset=0), FunctionDef('test_pdb_set_trace', arguments([], None, None, []), [Expr(Str('Using pdb.set_trace from a doctest.\n\n    You can use pdb.set_trace from a doctest.  To do so, you must\n    retrieve the set_trace function from the pdb module at the time\n    you use it.  The doctest module changes sys.stdout so that it can\n    capture program output.  It also temporarily replaces pdb.set_trace\n    with a version that restores stdout.  This is necessary for you to\n    see debugger output.\n\n      >>> doc = \'\'\'\n      ... >>> x = 42\n      ... >>> raise Exception(\'cl\xc3\xa9\')\n      ... Traceback (most recent call last):\n      ... Exception: cl\xc3\xa9\n      ... >>> import pdb; pdb.set_trace()\n      ... \'\'\'\n      >>> parser = doctest.DocTestParser()\n      >>> test = parser.get_doctest(doc, {}, "foo-b\xc3\xa4r@baz", "foo-b\xc3\xa4r@baz.py", 0)\n      >>> runner = doctest.DocTestRunner(verbose=False)\n\n    To demonstrate this, we\'ll create a fake standard input that\n    captures our debugger input:\n\n      >>> import tempfile\n      >>> real_stdin = sys.stdin\n      >>> sys.stdin = _FakeInput([\n      ...    \'print x\',  # print data defined by the example\n      ...    \'continue\', # stop debugging\n      ...    \'\'])\n\n      >>> try: runner.run(test)\n      ... finally: sys.stdin = real_stdin\n      --Return--\n      > <doctest foo-b\xc3\xa4r@baz[2]>(1)<module>()->None\n      -> import pdb; pdb.set_trace()\n      (Pdb) print x\n      42\n      (Pdb) continue\n      TestResults(failed=0, attempted=3)\n\n      You can also put pdb.set_trace in a function called from a test:\n\n      >>> def calls_set_trace():\n      ...    y=2\n      ...    import pdb; pdb.set_trace()\n\n      >>> doc = \'\'\'\n      ... >>> x=1\n      ... >>> calls_set_trace()\n      ... \'\'\'\n      >>> test = parser.get_doctest(doc, globals(), "foo-b\xc3\xa4r@baz", "foo-b\xc3\xa4r@baz.py", 0)\n      >>> real_stdin = sys.stdin\n      >>> sys.stdin = _FakeInput([\n      ...    \'print y\',  # print data defined in the function\n      ...    \'up\',       # out of function\n      ...    \'print x\',  # print data defined by the example\n      ...    \'continue\', # stop debugging\n      ...    \'\'])\n\n      >>> try:\n      ...     runner.run(test)\n      ... finally:\n      ...     sys.stdin = real_stdin\n      --Return--\n      > <doctest test.test_doctest.test_pdb_set_trace[8]>(3)calls_set_trace()->None\n      -> import pdb; pdb.set_trace()\n      (Pdb) print y\n      2\n      (Pdb) up\n      > <doctest foo-b\xc3\xa4r@baz[1]>(1)<module>()\n      -> calls_set_trace()\n      (Pdb) print x\n      1\n      (Pdb) continue\n      TestResults(failed=0, attempted=2)\n\n    During interactive debugging, source code is shown, even for\n    doctest examples:\n\n      >>> doc = \'\'\'\n      ... >>> def f(x):\n      ... ...     g(x*2)\n      ... >>> def g(x):\n      ... ...     print x+3\n      ... ...     import pdb; pdb.set_trace()\n      ... >>> f(3)\n      ... \'\'\'\n      >>> test = parser.get_doctest(doc, globals(), "foo-b\xc3\xa4r@baz", "foo-b\xc3\xa4r@baz.py", 0)\n      >>> real_stdin = sys.stdin\n      >>> sys.stdin = _FakeInput([\n      ...    \'list\',     # list source from example 2\n      ...    \'next\',     # return from g()\n      ...    \'list\',     # list source from example 1\n      ...    \'next\',     # return from f()\n      ...    \'list\',     # list source from example 3\n      ...    \'continue\', # stop debugging\n      ...    \'\'])\n      >>> try: runner.run(test)\n      ... finally: sys.stdin = real_stdin\n      ... # doctest: +NORMALIZE_WHITESPACE\n      --Return--\n      > <doctest foo-b\xc3\xa4r@baz[1]>(3)g()->None\n      -> import pdb; pdb.set_trace()\n      (Pdb) list\n        1     def g(x):\n        2         print x+3\n        3  ->     import pdb; pdb.set_trace()\n      [EOF]\n      (Pdb) next\n      --Return--\n      > <doctest foo-b\xc3\xa4r@baz[0]>(2)f()->None\n      -> g(x*2)\n      (Pdb) list\n        1     def f(x):\n        2  ->     g(x*2)\n      [EOF]\n      (Pdb) next\n      --Return--\n      > <doctest foo-b\xc3\xa4r@baz[2]>(1)<module>()->None\n      -> f(3)\n      (Pdb) list\n        1  -> f(3)\n      [EOF]\n      (Pdb) continue\n      **********************************************************************\n      File "foo-b\xc3\xa4r@baz.py", line 7, in foo-b\xc3\xa4r@baz\n      Failed example:\n          f(3)\n      Expected nothing\n      Got:\n          9\n      TestResults(failed=1, attempted=3)\n      ', lineno=1845, col_offset=-1), lineno=1845, col_offset=-1)], [], lineno=1712, col_offset=0), FunctionDef('test_pdb_set_trace_nested', arguments([], None, None, []), [Expr(Str('This illustrates more-demanding use of set_trace with nested functions.\n\n    >>> class C(object):\n    ...     def calls_set_trace(self):\n    ...         y = 1\n    ...         import pdb; pdb.set_trace()\n    ...         self.f1()\n    ...         y = 2\n    ...     def f1(self):\n    ...         x = 1\n    ...         self.f2()\n    ...         x = 2\n    ...     def f2(self):\n    ...         z = 1\n    ...         z = 2\n\n    >>> calls_set_trace = C().calls_set_trace\n\n    >>> doc = \'\'\'\n    ... >>> a = 1\n    ... >>> calls_set_trace()\n    ... \'\'\'\n    >>> parser = doctest.DocTestParser()\n    >>> runner = doctest.DocTestRunner(verbose=False)\n    >>> test = parser.get_doctest(doc, globals(), "foo-b\xc3\xa4r@baz", "foo-b\xc3\xa4r@baz.py", 0)\n    >>> real_stdin = sys.stdin\n    >>> sys.stdin = _FakeInput([\n    ...    \'print y\',  # print data defined in the function\n    ...    \'step\', \'step\', \'step\', \'step\', \'step\', \'step\', \'print z\',\n    ...    \'up\', \'print x\',\n    ...    \'up\', \'print y\',\n    ...    \'up\', \'print foo\',\n    ...    \'continue\', # stop debugging\n    ...    \'\'])\n\n    >>> try:\n    ...     runner.run(test)\n    ... finally:\n    ...     sys.stdin = real_stdin\n    > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(5)calls_set_trace()\n    -> self.f1()\n    (Pdb) print y\n    1\n    (Pdb) step\n    --Call--\n    > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(7)f1()\n    -> def f1(self):\n    (Pdb) step\n    > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(8)f1()\n    -> x = 1\n    (Pdb) step\n    > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(9)f1()\n    -> self.f2()\n    (Pdb) step\n    --Call--\n    > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(11)f2()\n    -> def f2(self):\n    (Pdb) step\n    > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(12)f2()\n    -> z = 1\n    (Pdb) step\n    > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(13)f2()\n    -> z = 2\n    (Pdb) print z\n    1\n    (Pdb) up\n    > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(9)f1()\n    -> self.f2()\n    (Pdb) print x\n    1\n    (Pdb) up\n    > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(5)calls_set_trace()\n    -> self.f1()\n    (Pdb) print y\n    1\n    (Pdb) up\n    > <doctest foo-b\xc3\xa4r@baz[1]>(1)<module>()\n    -> calls_set_trace()\n    (Pdb) print foo\n    *** NameError: name \'foo\' is not defined\n    (Pdb) continue\n    TestResults(failed=0, attempted=2)\n', lineno=1930, col_offset=-1), lineno=1930, col_offset=-1)], [], lineno=1847, col_offset=0), FunctionDef('test_DocTestSuite', arguments([], None, None, []), [Expr(Str("DocTestSuite creates a unittest test suite from a doctest.\n\n       We create a Suite by providing a module.  A module can be provided\n       by passing a module object:\n\n         >>> import unittest\n         >>> import test.sample_doctest\n         >>> suite = doctest.DocTestSuite(test.sample_doctest)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=4>\n\n       We can also supply the module by name:\n\n         >>> suite = doctest.DocTestSuite('test.sample_doctest')\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=4>\n\n       We can use the current module:\n\n         >>> suite = test.sample_doctest.test_suite()\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=4>\n\n       We can supply global variables.  If we pass globs, they will be\n       used instead of the module globals.  Here we'll pass an empty\n       globals, triggering an extra error:\n\n         >>> suite = doctest.DocTestSuite('test.sample_doctest', globs={})\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=5>\n\n       Alternatively, we can provide extra globals.  Here we'll make an\n       error go away by providing an extra global variable:\n\n         >>> suite = doctest.DocTestSuite('test.sample_doctest',\n         ...                              extraglobs={'y': 1})\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=3>\n\n       You can pass option flags.  Here we'll cause an extra error\n       by disabling the blank-line feature:\n\n         >>> suite = doctest.DocTestSuite('test.sample_doctest',\n         ...                      optionflags=doctest.DONT_ACCEPT_BLANKLINE)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=5>\n\n       You can supply setUp and tearDown functions:\n\n         >>> def setUp(t):\n         ...     import test.test_doctest\n         ...     test.test_doctest.sillySetup = True\n\n         >>> def tearDown(t):\n         ...     import test.test_doctest\n         ...     del test.test_doctest.sillySetup\n\n       Here, we installed a silly variable that the test expects:\n\n         >>> suite = doctest.DocTestSuite('test.sample_doctest',\n         ...      setUp=setUp, tearDown=tearDown)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=3>\n\n       But the tearDown restores sanity:\n\n         >>> import test.test_doctest\n         >>> test.test_doctest.sillySetup\n         Traceback (most recent call last):\n         ...\n         AttributeError: 'module' object has no attribute 'sillySetup'\n\n       The setUp and tearDown funtions are passed test objects. Here\n       we'll use the setUp function to supply the missing variable y:\n\n         >>> def setUp(test):\n         ...     test.globs['y'] = 1\n\n         >>> suite = doctest.DocTestSuite('test.sample_doctest', setUp=setUp)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=3>\n\n       Here, we didn't need to use a tearDown function because we\n       modified the test globals, which are a copy of the\n       sample_doctest module dictionary.  The test globals are\n       automatically cleared for us after a test.\n       ", lineno=2019, col_offset=-1), lineno=2019, col_offset=-1)], [], lineno=1932, col_offset=0), FunctionDef('test_DocFileSuite', arguments([], None, None, []), [Expr(Str("We can test tests found in text files using a DocFileSuite.\n\n       We create a suite by providing the names of one or more text\n       files that include examples:\n\n         >>> import unittest\n         >>> suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                              'test_doctest2.txt',\n         ...                              'test_doctest4.txt')\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=3 errors=0 failures=3>\n\n       The test files are looked for in the directory containing the\n       calling module.  A package keyword argument can be provided to\n       specify a different relative location.\n\n         >>> import unittest\n         >>> suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                              'test_doctest2.txt',\n         ...                              'test_doctest4.txt',\n         ...                              package='test')\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=3 errors=0 failures=3>\n\n       Support for using a package's __loader__.get_data() is also\n       provided.\n\n         >>> import unittest, pkgutil, test\n         >>> added_loader = False\n         >>> if not hasattr(test, '__loader__'):\n         ...     test.__loader__ = pkgutil.get_loader(test)\n         ...     added_loader = True\n         >>> try:\n         ...     suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                                  'test_doctest2.txt',\n         ...                                  'test_doctest4.txt',\n         ...                                  package='test')\n         ...     suite.run(unittest.TestResult())\n         ... finally:\n         ...     if added_loader:\n         ...         del test.__loader__\n         <unittest.result.TestResult run=3 errors=0 failures=3>\n\n       '/' should be used as a path separator.  It will be converted\n       to a native separator at run time:\n\n         >>> suite = doctest.DocFileSuite('../test/test_doctest.txt')\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=1 errors=0 failures=1>\n\n       If DocFileSuite is used from an interactive session, then files\n       are resolved relative to the directory of sys.argv[0]:\n\n         >>> import types, os.path, test.test_doctest\n         >>> save_argv = sys.argv\n         >>> sys.argv = [test.test_doctest.__file__]\n         >>> suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                              package=types.ModuleType('__main__'))\n         >>> sys.argv = save_argv\n\n       By setting `module_relative=False`, os-specific paths may be\n       used (including absolute paths and paths relative to the\n       working directory):\n\n         >>> # Get the absolute path of the test package.\n         >>> test_doctest_path = os.path.abspath(test.test_doctest.__file__)\n         >>> test_pkg_path = os.path.split(test_doctest_path)[0]\n\n         >>> # Use it to find the absolute path of test_doctest.txt.\n         >>> test_file = os.path.join(test_pkg_path, 'test_doctest.txt')\n\n         >>> suite = doctest.DocFileSuite(test_file, module_relative=False)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=1 errors=0 failures=1>\n\n       It is an error to specify `package` when `module_relative=False`:\n\n         >>> suite = doctest.DocFileSuite(test_file, module_relative=False,\n         ...                              package='test')\n         Traceback (most recent call last):\n         ValueError: Package may only be specified for module-relative paths.\n\n       You can specify initial global variables:\n\n         >>> suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                              'test_doctest2.txt',\n         ...                              'test_doctest4.txt',\n         ...                              globs={'favorite_color': 'blue'})\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=3 errors=0 failures=2>\n\n       In this case, we supplied a missing favorite color. You can\n       provide doctest options:\n\n         >>> suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                              'test_doctest2.txt',\n         ...                              'test_doctest4.txt',\n         ...                         optionflags=doctest.DONT_ACCEPT_BLANKLINE,\n         ...                              globs={'favorite_color': 'blue'})\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=3 errors=0 failures=3>\n\n       And, you can provide setUp and tearDown functions:\n\n         >>> def setUp(t):\n         ...     import test.test_doctest\n         ...     test.test_doctest.sillySetup = True\n\n         >>> def tearDown(t):\n         ...     import test.test_doctest\n         ...     del test.test_doctest.sillySetup\n\n       Here, we installed a silly variable that the test expects:\n\n         >>> suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                              'test_doctest2.txt',\n         ...                              'test_doctest4.txt',\n         ...                              setUp=setUp, tearDown=tearDown)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=3 errors=0 failures=2>\n\n       But the tearDown restores sanity:\n\n         >>> import test.test_doctest\n         >>> test.test_doctest.sillySetup\n         Traceback (most recent call last):\n         ...\n         AttributeError: 'module' object has no attribute 'sillySetup'\n\n       The setUp and tearDown funtions are passed test objects.\n       Here, we'll use a setUp function to set the favorite color in\n       test_doctest.txt:\n\n         >>> def setUp(test):\n         ...     test.globs['favorite_color'] = 'blue'\n\n         >>> suite = doctest.DocFileSuite('test_doctest.txt', setUp=setUp)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=1 errors=0 failures=0>\n\n       Here, we didn't need to use a tearDown function because we\n       modified the test globals.  The test globals are\n       automatically cleared for us after a test.\n\n       Tests in a file run using `DocFileSuite` can also access the\n       `__file__` global, which is set to the name of the file\n       containing the tests:\n\n         >>> suite = doctest.DocFileSuite('test_doctest3.txt')\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=1 errors=0 failures=0>\n\n       If the tests contain non-ASCII characters, we have to specify which\n       encoding the file is encoded with. We do so by using the `encoding`\n       parameter:\n\n         >>> suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                              'test_doctest2.txt',\n         ...                              'test_doctest4.txt',\n         ...                              encoding='utf-8')\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=3 errors=0 failures=2>\n\n       ", lineno=2185, col_offset=-1), lineno=2185, col_offset=-1)], [], lineno=2021, col_offset=0), FunctionDef('test_trailing_space_in_test', arguments([], None, None, []), [Expr(Str("\n    Trailing spaces in expected output are significant:\n\n      >>> x, y = 'foo', ''\n      >>> print x, y\n      foo \n\n    ", lineno=2194, col_offset=-1), lineno=2194, col_offset=-1)], [], lineno=2187, col_offset=0), FunctionDef('test_unittest_reportflags', arguments([], None, None, []), [Expr(Str("Default unittest reporting flags can be set to control reporting\n\n    Here, we'll set the REPORT_ONLY_FIRST_FAILURE option so we see\n    only the first failure of each test.  First, we'll look at the\n    output without the flag.  The file test_doctest.txt file has two\n    tests. They both fail if blank lines are disabled:\n\n      >>> suite = doctest.DocFileSuite('test_doctest.txt',\n      ...                          optionflags=doctest.DONT_ACCEPT_BLANKLINE)\n      >>> import unittest\n      >>> result = suite.run(unittest.TestResult())\n      >>> print result.failures[0][1] # doctest: +ELLIPSIS\n      Traceback ...\n      Failed example:\n          favorite_color\n      ...\n      Failed example:\n          if 1:\n      ...\n\n    Note that we see both failures displayed.\n\n      >>> old = doctest.set_unittest_reportflags(\n      ...    doctest.REPORT_ONLY_FIRST_FAILURE)\n\n    Now, when we run the test:\n\n      >>> result = suite.run(unittest.TestResult())\n      >>> print result.failures[0][1] # doctest: +ELLIPSIS\n      Traceback ...\n      Failed example:\n          favorite_color\n      Exception raised:\n          ...\n          NameError: name 'favorite_color' is not defined\n      <BLANKLINE>\n      <BLANKLINE>\n\n    We get only the first failure.\n\n    If we give any reporting options when we set up the tests,\n    however:\n\n      >>> suite = doctest.DocFileSuite('test_doctest.txt',\n      ...     optionflags=doctest.DONT_ACCEPT_BLANKLINE | doctest.REPORT_NDIFF)\n\n    Then the default eporting options are ignored:\n\n      >>> result = suite.run(unittest.TestResult())\n      >>> print result.failures[0][1] # doctest: +ELLIPSIS\n      Traceback ...\n      Failed example:\n          favorite_color\n      ...\n      Failed example:\n          if 1:\n             print 'a'\n             print\n             print 'b'\n      Differences (ndiff with -expected +actual):\n            a\n          - <BLANKLINE>\n          +\n            b\n      <BLANKLINE>\n      <BLANKLINE>\n\n\n    Test runners can restore the formatting flags after they run:\n\n      >>> ignored = doctest.set_unittest_reportflags(old)\n\n    ", lineno=2270, col_offset=-1), lineno=2270, col_offset=-1)], [], lineno=2197, col_offset=0), FunctionDef('test_testfile', arguments([], None, None, []), [Expr(Str('\nTests for the `testfile()` function.  This function runs all the\ndoctest examples in a given file.  In its simple invokation, it is\ncalled with the name of a file, which is taken to be relative to the\ncalling module.  The return value is (#failures, #tests).\n\nWe don\'t want `-v` in sys.argv for these tests.\n\n    >>> save_argv = sys.argv\n    >>> if \'-v\' in sys.argv:\n    ...     sys.argv = [arg for arg in save_argv if arg != \'-v\']\n\n\n    >>> doctest.testfile(\'test_doctest.txt\') # doctest: +ELLIPSIS\n    **********************************************************************\n    File "...", line 6, in test_doctest.txt\n    Failed example:\n        favorite_color\n    Exception raised:\n        ...\n        NameError: name \'favorite_color\' is not defined\n    **********************************************************************\n    1 items had failures:\n       1 of   2 in test_doctest.txt\n    ***Test Failed*** 1 failures.\n    TestResults(failed=1, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\n(Note: we\'ll be clearing doctest.master after each call to\n`doctest.testfile`, to suppress warnings about multiple tests with the\nsame name.)\n\nGlobals may be specified with the `globs` and `extraglobs` parameters:\n\n    >>> globs = {\'favorite_color\': \'blue\'}\n    >>> doctest.testfile(\'test_doctest.txt\', globs=globs)\n    TestResults(failed=0, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\n    >>> extraglobs = {\'favorite_color\': \'red\'}\n    >>> doctest.testfile(\'test_doctest.txt\', globs=globs,\n    ...                  extraglobs=extraglobs) # doctest: +ELLIPSIS\n    **********************************************************************\n    File "...", line 6, in test_doctest.txt\n    Failed example:\n        favorite_color\n    Expected:\n        \'blue\'\n    Got:\n        \'red\'\n    **********************************************************************\n    1 items had failures:\n       1 of   2 in test_doctest.txt\n    ***Test Failed*** 1 failures.\n    TestResults(failed=1, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\nThe file may be made relative to a given module or package, using the\noptional `module_relative` parameter:\n\n    >>> doctest.testfile(\'test_doctest.txt\', globs=globs,\n    ...                  module_relative=\'test\')\n    TestResults(failed=0, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\nVerbosity can be increased with the optional `verbose` paremter:\n\n    >>> doctest.testfile(\'test_doctest.txt\', globs=globs, verbose=True)\n    Trying:\n        favorite_color\n    Expecting:\n        \'blue\'\n    ok\n    Trying:\n        if 1:\n           print \'a\'\n           print\n           print \'b\'\n    Expecting:\n        a\n        <BLANKLINE>\n        b\n    ok\n    1 items passed all tests:\n       2 tests in test_doctest.txt\n    2 tests in 1 items.\n    2 passed and 0 failed.\n    Test passed.\n    TestResults(failed=0, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\nThe name of the test may be specified with the optional `name`\nparameter:\n\n    >>> doctest.testfile(\'test_doctest.txt\', name=\'newname\')\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File "...", line 6, in newname\n    ...\n    TestResults(failed=1, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\nThe summary report may be supressed with the optional `report`\nparameter:\n\n    >>> doctest.testfile(\'test_doctest.txt\', report=False)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File "...", line 6, in test_doctest.txt\n    Failed example:\n        favorite_color\n    Exception raised:\n        ...\n        NameError: name \'favorite_color\' is not defined\n    TestResults(failed=1, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\nThe optional keyword argument `raise_on_error` can be used to raise an\nexception on the first error (which may be useful for postmortem\ndebugging):\n\n    >>> doctest.testfile(\'test_doctest.txt\', raise_on_error=True)\n    ... # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n    UnexpectedException: ...\n    >>> doctest.master = None  # Reset master.\n\nIf the tests contain non-ASCII characters, the tests might fail, since\nit\'s unknown which encoding is used. The encoding can be specified\nusing the optional keyword argument `encoding`:\n\n    >>> doctest.testfile(\'test_doctest4.txt\') # doctest: +ELLIPSIS\n    **********************************************************************\n    File "...", line 7, in test_doctest4.txt\n    Failed example:\n        u\'...\'\n    Expected:\n        u\'f\\xf6\\xf6\'\n    Got:\n        u\'f\\xc3\\xb6\\xc3\\xb6\'\n    **********************************************************************\n    ...\n    **********************************************************************\n    1 items had failures:\n       2 of   4 in test_doctest4.txt\n    ***Test Failed*** 2 failures.\n    TestResults(failed=2, attempted=4)\n    >>> doctest.master = None  # Reset master.\n\n    >>> doctest.testfile(\'test_doctest4.txt\', encoding=\'utf-8\')\n    TestResults(failed=0, attempted=4)\n    >>> doctest.master = None  # Reset master.\n\nSwitch the module encoding to \'utf-8\' to test the verbose output without\nbothering with the current sys.stdout encoding.\n\n    >>> doctest._encoding, saved_encoding = \'utf-8\', doctest._encoding\n    >>> doctest.testfile(\'test_doctest4.txt\', encoding=\'utf-8\', verbose=True)\n    Trying:\n        u\'f\xc3\xb6\xc3\xb6\'\n    Expecting:\n        u\'f\\xf6\\xf6\'\n    ok\n    Trying:\n        u\'b\xc4\x85r\'\n    Expecting:\n        u\'b\\u0105r\'\n    ok\n    Trying:\n        \'f\xc3\xb6\xc3\xb6\'\n    Expecting:\n        \'f\\xc3\\xb6\\xc3\\xb6\'\n    ok\n    Trying:\n        \'b\xc4\x85r\'\n    Expecting:\n        \'b\\xc4\\x85r\'\n    ok\n    1 items passed all tests:\n       4 tests in test_doctest4.txt\n    4 tests in 1 items.\n    4 passed and 0 failed.\n    Test passed.\n    TestResults(failed=0, attempted=4)\n    >>> doctest._encoding = saved_encoding\n    >>> doctest.master = None  # Reset master.\n    >>> sys.argv = save_argv\n', lineno=2459, col_offset=-1), lineno=2459, col_offset=-1)], [], lineno=2272, col_offset=0), FunctionDef('old_test1', arguments([], None, None, []), [Expr(Str('\n>>> from doctest import Tester\n>>> t = Tester(globs={\'x\': 42}, verbose=0)\n>>> t.runstring(r\'\'\'\n...      >>> x = x * 2\n...      >>> print x\n...      42\n... \'\'\', \'XYZ\')\n**********************************************************************\nLine 3, in XYZ\nFailed example:\n    print x\nExpected:\n    42\nGot:\n    84\nTestResults(failed=1, attempted=2)\n>>> t.runstring(">>> x = x * 2\\n>>> print x\\n84\\n", \'example2\')\nTestResults(failed=0, attempted=2)\n>>> t.summarize()\n**********************************************************************\n1 items had failures:\n   1 of   2 in XYZ\n***Test Failed*** 1 failures.\nTestResults(failed=1, attempted=4)\n>>> t.summarize(verbose=1)\n1 items passed all tests:\n   2 tests in example2\n**********************************************************************\n1 items had failures:\n   1 of   2 in XYZ\n4 tests in 2 items.\n3 passed and 1 failed.\n***Test Failed*** 1 failures.\nTestResults(failed=1, attempted=4)\n', lineno=2500, col_offset=-1), lineno=2500, col_offset=-1)], [], lineno=2465, col_offset=0), FunctionDef('old_test2', arguments([], None, None, []), [Expr(Str('\n        >>> from doctest import Tester\n        >>> t = Tester(globs={}, verbose=1)\n        >>> test = r\'\'\'\n        ...    # just an example\n        ...    >>> x = 1 + 2\n        ...    >>> x\n        ...    3\n        ... \'\'\'\n        >>> t.runstring(test, "Example")\n        Running string Example\n        Trying:\n            x = 1 + 2\n        Expecting nothing\n        ok\n        Trying:\n            x\n        Expecting:\n            3\n        ok\n        0 of 2 examples failed in string Example\n        TestResults(failed=0, attempted=2)\n', lineno=2524, col_offset=-1), lineno=2524, col_offset=-1)], [], lineno=2502, col_offset=0), FunctionDef('old_test3', arguments([], None, None, []), [Expr(Str("\n        >>> from doctest import Tester\n        >>> t = Tester(globs={}, verbose=0)\n        >>> def _f():\n        ...     '''Trivial docstring example.\n        ...     >>> assert 2 == 2\n        ...     '''\n        ...     return 32\n        ...\n        >>> t.rundoc(_f)  # expect 0 failures in 1 example\n        TestResults(failed=0, attempted=1)\n", lineno=2537, col_offset=-1), lineno=2537, col_offset=-1)], [], lineno=2526, col_offset=0), FunctionDef('old_test4', arguments([], None, None, []), [Expr(Str('\n        >>> import types\n        >>> m1 = types.ModuleType(\'_m1\')\n        >>> m2 = types.ModuleType(\'_m2\')\n        >>> test_data = """\n        ... def _f():\n        ...     \'\'\'>>> assert 1 == 1\n        ...     \'\'\'\n        ... def g():\n        ...    \'\'\'>>> assert 2 != 1\n        ...    \'\'\'\n        ... class H:\n        ...    \'\'\'>>> assert 2 > 1\n        ...    \'\'\'\n        ...    def bar(self):\n        ...        \'\'\'>>> assert 1 < 2\n        ...        \'\'\'\n        ... """\n        >>> exec test_data in m1.__dict__\n        >>> exec test_data in m2.__dict__\n        >>> m1.__dict__.update({"f2": m2._f, "g2": m2.g, "h2": m2.H})\n\n        Tests that objects outside m1 are excluded:\n\n        >>> from doctest import Tester\n        >>> t = Tester(globs={}, verbose=0)\n        >>> t.rundict(m1.__dict__, "rundict_test", m1)  # f2 and g2 and h2 skipped\n        TestResults(failed=0, attempted=4)\n\n        Once more, not excluding stuff outside m1:\n\n        >>> t = Tester(globs={}, verbose=0)\n        >>> t.rundict(m1.__dict__, "rundict_test_pvt")  # None are skipped.\n        TestResults(failed=0, attempted=8)\n\n        The exclusion of objects from outside the designated module is\n        meant to be invoked automagically by testmod.\n\n        >>> doctest.testmod(m1, verbose=False)\n        TestResults(failed=0, attempted=4)\n', lineno=2579, col_offset=-1), lineno=2579, col_offset=-1)], [], lineno=2539, col_offset=0), FunctionDef('test_main', arguments([], None, None, []), [Expr(Call(Attribute(Name('test_support', Load(), lineno=2587, col_offset=4), 'run_doctest', Load(), lineno=2587, col_offset=4), [Name('doctest', Load(), lineno=2587, col_offset=29)], [keyword('verbosity', Name('True', Load(), lineno=2587, col_offset=48))], None, None, lineno=2587, col_offset=4), lineno=2587, col_offset=4), ImportFrom('test', [alias('test_doctest', None)], 0, lineno=2589, col_offset=4), Assign([Name('deprecations', Store(), lineno=2592, col_offset=4)], List([Tuple([Str('class Tester is deprecated', lineno=2592, col_offset=21), Name('DeprecationWarning', Load(), lineno=2592, col_offset=51)], Load(), lineno=2592, col_offset=21)], Load(), lineno=2592, col_offset=19), lineno=2592, col_offset=4), If(Attribute(Name('sys', Load(), lineno=2593, col_offset=7), 'py3kwarning', Load(), lineno=2593, col_offset=7), [AugAssign(Name('deprecations', Store(), lineno=2594, col_offset=8), Add(), List([Tuple([Str('backquote not supported', lineno=2594, col_offset=26), Name('SyntaxWarning', Load(), lineno=2594, col_offset=53)], Load(), lineno=2594, col_offset=26), Tuple([Str('execfile.. not supported', lineno=2595, col_offset=26), Name('DeprecationWarning', Load(), lineno=2595, col_offset=54)], Load(), lineno=2595, col_offset=26)], Load(), lineno=2594, col_offset=24), lineno=2594, col_offset=8)], [], lineno=2593, col_offset=4), With(Call(Attribute(Name('test_support', Load(), lineno=2596, col_offset=9), 'check_warnings', Load(), lineno=2596, col_offset=9), [], [], Name('deprecations', Load(), lineno=2596, col_offset=38), None, lineno=2596, col_offset=9), None, [Expr(Call(Attribute(Name('test_support', Load(), lineno=2598, col_offset=8), 'run_doctest', Load(), lineno=2598, col_offset=8), [Name('test_doctest', Load(), lineno=2598, col_offset=33)], [keyword('verbosity', Name('True', Load(), lineno=2598, col_offset=57))], None, None, lineno=2598, col_offset=8), lineno=2598, col_offset=8)], lineno=2596, col_offset=9)], [], lineno=2585, col_offset=0), Import([alias('sys', None)], lineno=2600, col_offset=0), FunctionDef('test_coverage', arguments([Name('coverdir', Param(), lineno=2601, col_offset=18)], None, None, []), [Assign([Name('trace', Store(), lineno=2602, col_offset=4)], Call(Attribute(Name('test_support', Load(), lineno=2602, col_offset=12), 'import_module', Load(), lineno=2602, col_offset=12), [Str('trace', lineno=2602, col_offset=39)], [], None, None, lineno=2602, col_offset=12), lineno=2602, col_offset=4), Assign([Name('tracer', Store(), lineno=2603, col_offset=4)], Call(Attribute(Name('trace', Load(), lineno=2603, col_offset=13), 'Trace', Load(), lineno=2603, col_offset=13), [], [keyword('ignoredirs', List([Attribute(Name('sys', Load(), lineno=2603, col_offset=37), 'prefix', Load(), lineno=2603, col_offset=37), Attribute(Name('sys', Load(), lineno=2603, col_offset=49), 'exec_prefix', Load(), lineno=2603, col_offset=49)], Load(), lineno=2603, col_offset=36)), keyword('trace', Num(0, lineno=2604, col_offset=31)), keyword('count', Num(1, lineno=2604, col_offset=40))], None, None, lineno=2603, col_offset=13), lineno=2603, col_offset=4), Expr(Call(Attribute(Name('tracer', Load(), lineno=2605, col_offset=4), 'run', Load(), lineno=2605, col_offset=4), [Str('reload(doctest); test_main()', lineno=2605, col_offset=15)], [], None, None, lineno=2605, col_offset=4), lineno=2605, col_offset=4), Assign([Name('r', Store(), lineno=2606, col_offset=4)], Call(Attribute(Name('tracer', Load(), lineno=2606, col_offset=8), 'results', Load(), lineno=2606, col_offset=8), [], [], None, None, lineno=2606, col_offset=8), lineno=2606, col_offset=4), Print(None, [Str('Writing coverage results...', lineno=2607, col_offset=10)], True, lineno=2607, col_offset=4), Expr(Call(Attribute(Name('r', Load(), lineno=2608, col_offset=4), 'write_results', Load(), lineno=2608, col_offset=4), [], [keyword('show_missing', Name('True', Load(), lineno=2608, col_offset=33)), keyword('summary', Name('True', Load(), lineno=2608, col_offset=47)), keyword('coverdir', Name('coverdir', Load(), lineno=2609, col_offset=29))], None, None, lineno=2608, col_offset=4), lineno=2608, col_offset=4)], [], lineno=2601, col_offset=0), If(Compare(Name('__name__', Load(), lineno=2611, col_offset=3), [Eq()], [Str('__main__', lineno=2611, col_offset=15)], lineno=2611, col_offset=3), [If(Compare(Str('-c', lineno=2612, col_offset=7), [In()], [Attribute(Name('sys', Load(), lineno=2612, col_offset=15), 'argv', Load(), lineno=2612, col_offset=15)], lineno=2612, col_offset=7), [Expr(Call(Name('test_coverage', Load(), lineno=2613, col_offset=8), [Str('/tmp/doctest.cover', lineno=2613, col_offset=22)], [], None, None, lineno=2613, col_offset=8), lineno=2613, col_offset=8)], [Expr(Call(Name('test_main', Load(), lineno=2615, col_offset=8), [], [], None, None, lineno=2615, col_offset=8), lineno=2615, col_offset=8)], lineno=2612, col_offset=4)], [], lineno=2611, col_offset=0)])
