Module([Expr(Str('\nBroken bytecode objects can easily crash the interpreter.\n\nThis is not going to be fixed.  It is generally agreed that there is no\npoint in writing a bytecode verifier and putting it in CPython just for\nthis.  Moreover, a verifier is bound to accept only a subset of all safe\nbytecodes, so it could lead to unnecessary breakage.\n\nFor security purposes, "restricted" interpreters are not going to let\nthe user build or load random bytecodes anyway.  Otherwise, this is a\n"won\'t fix" case.\n\n', lineno=13, col_offset=-1), lineno=13, col_offset=-1), Import([alias('types', None)], lineno=15, col_offset=0), Assign([Name('co', Store(), lineno=17, col_offset=0)], Call(Attribute(Name('types', Load(), lineno=17, col_offset=5), 'CodeType', Load(), lineno=17, col_offset=5), [Num(0, lineno=17, col_offset=20), Num(0, lineno=17, col_offset=23), Num(0, lineno=17, col_offset=26), Num(0, lineno=17, col_offset=29), Str('\x04q\x00\x00', lineno=17, col_offset=32), Tuple([], Load(), lineno=17, col_offset=52), Tuple([], Load(), lineno=18, col_offset=20), Tuple([], Load(), lineno=18, col_offset=24), Str('', lineno=18, col_offset=28), Str('', lineno=18, col_offset=32), Num(1, lineno=18, col_offset=36), Str('', lineno=18, col_offset=39)], [], None, None, lineno=17, col_offset=5), lineno=17, col_offset=0), Exec(Name('co', Load(), lineno=19, col_offset=5), None, None, lineno=19, col_offset=0)])
